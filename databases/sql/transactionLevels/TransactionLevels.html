<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Уровень изолированности транзакций</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>

<body>
    <h1>Уровень изолированности транзакций</h1>

    <h3>Проблемы параллельного доступа с использованием транзакций:</h3>
    <ol>
        <li>
            <div><b>Потерянное обновление -</b> cитуация, когда при одновременном изменении одного блока данных разными
                транзакциями
                одно из изменений теряется.
            </div>
            <table class="wikitable">
                <tbody>
                <tr>
                    <th>Транзакция 1
                    </th>
                    <th>Транзакция 2
                    </th>
                </tr>
                <tr>
                    <td><code>UPDATE tbl1 SET f2=f2+20 WHERE f1=1;</code>
                    </td>
                    <td><code>UPDATE tbl1 SET f2=f2+25 WHERE f1=1;</code>
                    </td>
                </tr>
                </tbody>
            </table>
        </li>
        <li>
            <div><b>«Грязное» чтение - </b> чтение данных, добавленных или изменённых транзакцией, которая впоследствии
                не
                подтвердится (откатится).
            </div>
            <table class="wikitable">

                <tbody>
                <tr>
                    <th>Транзакция 1
                    </th>
                    <th>Транзакция 2
                    </th>
                </tr>
                <tr>
                    <td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>
                    </td>
                    <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code>
                    </td>
                </tr>
                <tr>
                    <td><code>ROLLBACK WORK;</code>
                    </td>
                    <td>
                    </td>
                </tr>
                </tbody>
            </table>
        </li>
        </li>
        <li>
            <div><b>Неповторяющееся чтение - </b> cитуация, когда при повторном чтении в рамках одной транзакции ранее
                прочитанные данные оказываются изменёнными.
            </div>
            <table class="wikitable">
                <tbody>
                <tr>
                    <th>Транзакция 1
                    </th>
                    <th>Транзакция 2
                    </th>
                </tr>
                <tr>
                    <td>
                    </td>
                    <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code>
                    </td>
                </tr>
                <tr>
                    <td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td><code>COMMIT;</code>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>
                    </td>
                    <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code>
                    </td>
                </tr>
                </tbody>
            </table>
        </li>
        <li>
            <div><b>Чтение «фантомов» - </b> cитуация, когда при повторном чтении в рамках одной транзакции одна и та же
                выборка дает разные множества строк.
            </div>
            <table class="wikitable">

                <tbody>
                <tr>
                    <th>Транзакция 1
                    </th>
                    <th>Транзакция 2
                    </th>
                </tr>
                <tr>
                    <td>
                    </td>
                    <td><code>SELECT SUM(f2) FROM tbl1;</code>
                    </td>
                </tr>
                <tr>
                    <td><code>INSERT INTO tbl1 (f1,f2) VALUES (15,20);</code>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td><code>COMMIT;</code>
                    </td>
                    <td>
                    </td>
                </tr>
                <tr>
                    <td>
                    </td>
                    <td><code>SELECT SUM(f2) FROM tbl1;</code>
                    </td>
                </tr>
                </tbody>
            </table>
        </li>
    </ol>

    <h3>Уровни изоляции:</h3>
    <ol>
        <li>
            <div><b>Read uncommitted (чтение незафиксированных данных) - </b>>Низший (первый) уровень изоляции.
                Он гарантирует только отсутствие потерянных обновлений[1]. Если несколько параллельных транзакций
                пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение,
                определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только
                логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.<br>

                Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды
                изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно,
                фактически выполняются последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие
                только чтение, при данном уровне изоляции никогда не блокируются.
            </div>
        </li>
        <li>
            <div><b>Read committed (чтение фиксированных данных) - </b>Большинство промышленных СУБД, в частности,
                Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. На этом
                уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной
                транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая
                транзакция будет работать с другим набором данных.<br>

                Реализация завершённого чтения может основываться на одном из двух подходов: блокировании или
                версионности.
                <ol>
                    <li><b>Блокирование читаемых и изменяемых данных.</b>
                        Заключается в том, что пишущая транзакция блокирует изменяемые данные для читающих транзакций,
                        работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким
                        образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу
                        после
                        завершения операции SELECT (таким образом, ситуация «неповторяющегося чтения» может возникать
                        на данном уровне изоляции).
                    </li>
                    <li><b>Сохранение нескольких версий параллельно изменяемых строк.</b>
                        При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать
                        изменившая данные транзакция, в то время как любой другой «читающей» транзакции возвращается
                        последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает
                        бо́льшую
                        скорость, так как предотвращает блокировки. Однако он требует, по сравнению с первым,
                        существенно
                        бо́льшего расхода оперативной памяти, которая тратится на хранение версий строк. Кроме того, при
                        параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько
                        параллельных транзакций произведут несогласованные изменения одних и тех же данных (поскольку
                        блокировки отсутствуют, ничто не помешает это сделать). Тогда та транзакция, которая
                        зафиксируется
                        первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется
                        невозможно зафиксировать (так как это приведёт к потере обновления первой транзакции).
                        Единственное,
                        что может в такой ситуации СУБД — это откатить остальные транзакции и выдать сообщение об ошибке
                        «Запись уже изменена».
                        Конкретный способ реализации выбирается разработчиками СУБД, а в ряде случаев может
                        настраиваться.
                        Так, по умолчанию MS SQL использует блокировки, но (в версии 2005 и выше) при установке
                        параметра
                        READ_COMMITTED_SNAPSHOT базы данных переходит на стратегию версионности, Oracle исходно работает
                        только по версионной схеме. В Informix можно предотвратить конфликты между читающими и пишущими
                        транзакциями, установив параметр конфигурации USELASTCOMMITTED (начиная с версии 11.1), при этом
                        читающая транзакция будет получать последние подтвержденные данные
                    </li>
                </ol>
            </div>
        <li>
            <div><b>Repeatable read (повторяемость чтения)</b>
                Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны.
                При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не
                окончена.

                Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией транзакции, и
                сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые были считаны
                незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки, соответствующие
                условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске инструкции текущей
                транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая то, что разделяющие
                блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой инструкции, степень
                параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным и более высокими
                уровнями транзакций без необходимости обычно не рекомендуется.
            </div>
        </li>
        <li>
            <div>
                <b>Serializable (упорядочиваемость)</b>
                Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая
                выполняется
                последовательно, как будто параллельных транзакций не существует. Только на этом уровне параллельные
                транзакции не подвержены эффекту «фантомного чтения».
            </div>
        </li>
    </ol>

<h2>ШПАРГАЛКИ:</h2>
<h4>СРАВНЕНИЕ ВЫБОРКИ С ИНДЕКСОМ И БЕЗ:</h4>
<pre>
        вариант с:
        SELECT * FROM table WHERE ...
        вариант без:
        SELECT * FROM table WITH (INDEX(0)) WHERE …
    </pre>

</body>
</html>