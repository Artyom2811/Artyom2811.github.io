<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Scala</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>
<body>
<!--<ul class="breadcrumb">-->
<!--    <li><a href="../index.html">Main Page</a></li>-->
<!--    <li>JAVA</li>-->
<!--</ul>-->
<div><a href="../ProgrammingLanguages.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Scala(Scalable Language)</h1>
    <div> Это многопарадигмальный язык программирования. Он поддерживает как объектно-ориентированный, так и
        функциональный язык программирования. Это работает для JVM (виртуальная машина Java).
    </div>
    <ol>Основные разделы:
        <li><a href="collections/Collections.html">Collections</a></li>
    </ol>

    <ol>Основной stack scala:
        <li>SBT(scala build tool) - система сборки проекта</li>
        <li>Play Framework - MVC фреймворк.</li>
        <li>Slick - Библиотека работы с БД (http://scala-slick.org/)</li>
        <li>Quill - Библиотека работы с БД (https://getquill.io/)</li>
        <li>Silhouette - Библиотека для аутентификации</li>
    </ol>

    <p>Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется как
        вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в
        процедурном программировании). На практике отличие математической функции от понятия «функции» в
        императивном программировании заключается в том, что императивные функции могут опираться не только
        на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные
        эффекты и менять состояние внешних переменных. Таким образом, в императивном программировании при
        вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма,
        можно получить разные данные на выходе из-за влияния на функцию состояния переменных. А в функциональном
        языке при вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные
        данные зависят только от входных. Это позволяет средам выполнения программ на функциональных языках кешировать
        результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо
        дополнительных действий со стороны программиста
    </p>
    <p>Side effect - это действие, которое выходит за границы функции.</p>
    <div>Implicit(Неявное)
        <ol>
            <li>Неявные параметры - параметры соответствующих типов которые будут переданы в качестве параметров.</li>
            <li>Неявные преобразования - позволяют автоматически преобразовать значение одного типа к другому.
                <pre>
case class A(i: Int)
case class B(i: Int)

implicit def aToB(a: A): B = B(a.i)

val a = A(1)
val b: B = a
println(b)
        </pre>
            </li>
            <li>Неявные классы</li>
        </ol>
        <ol>Пустые типы в scala:
            <li>Nothing - - это самый нижний тип. Переменную с таким типом можно присвоить любое значение. Exception
                возвращает Nothing
            </li>
            <li>Null - trait который реализован в null</li>
            <li>null - наследник всех объектов, но не наследник всех примитивов.</li>
            <li>Nil - представление пустых списков</li>
            <li>Unit или () - Эквивалент Java void, который используется для функций, не имеющих возвращаемого типа
            </li>
            <li>None - Использует Option</li>
        </ol>
    </div>

    <p>Option - необходим как обёртка над значением(Some()) или его отсутствие(None). И можно без риска использовать
        функции высшего порядка над переменной(map и тд.)
    </p>
    <p>Either[Error, T] - это тип, который содержит либо значение, либо исключение.</p>
    <p>Try[T] - это подмножество "Either[Error, T]", который содержит либо значение, либо исключение.
        Может быть мутирован в Option.
    </p>
    <h3>Способы вызова функции:</h3>
    <p>
        Вызов по значения - def callByValue(x: Int) = {} - переменная будет получена один раз и переиспользоваться в
        методе
    </p>
    <p>
        Вызов по имени - def callByName(x: => Int) = {} - переменная будет переполучаться при каждом вызове x в методе
    </p>
    <p>
        <b>Функция высшего порядка(Higher-order function)</b> - функция/метод которая принимающая в качестве аргументов
        другие функции
        или возвращающая другую функцию в качестве результата. Также в нее можно передать метод.
    </p>
    <pre>С использование функции
def f(x: Int) = x + 3

def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(f, 7))
    </pre>
    <pre>С использованием анонимной функции
def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(_ + 3, 7))
    </pre>
    <ul>Чистые функции - функции, которые не имеют побочных эффектов ввода-вывода и памяти
        <li>если результат чистой функции не используется, её вызов может быть удалён без вреда для других выражений
        </li>
        <li>результат вызова чистой функции может быть мемоизирован, то есть сохранён в таблице значений вместе с
            аргументами вызова
        </li>
        <li>если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их вычисления можно
            поменять или распараллеливать (говоря иначе, вычисление чистых функций удовлетворяет принципам
            потокобезопасности)
        </li>
    </ul>
    <ul>Immutable Object - называется объект, состояние которого не может быть изменено после создания.
        <li>Блокировка для многопоточности больше не является проблемой: если данные не изменяются, нет необходимости в
            какой-либо блокировке, чтобы синхронизировать разные потоки
        </li>
        <li>хранение (persistence) — ещё один ключевой концепт, который мы рассмотрим позже, становится проще</li>
        <li>копирование возможно за константное время, потому что этот процесс становится лишь вопросом создания новой
            ссылки на уже существующий экземпляр структуры данных
        </li>
    </ul>
    <p>Недостатки Immutable - используется много Heap(молодой) памяти, так как часто удаляются уже использованные
        объекты.</p>
    <p>Как посчитать количество одинаковых элементов в List?</p>
    <pre>
val foo = List("r", "r",  "s",  "s",  "x",  "x").toStream.groupBy(i => i).mapValues(_.size)
    </pre>
    <p>Exception - в Scala исключения действуют так же как и в JAVA, но тут нет "checked"(то есть компилятор их не
        проверяет) исключений.
        Выражение trow имеет специальный тип Nothing.
    </p>
    <p>Error - не обрабатываемые исключения тк после из возникновений нет гарантий что программа будет выполняться
        корректно.</p>

</div>
</body>
</html>

<!--НЕ РАСПРЕДЕЛЕННЫЕ-->
<!--Type class vs case class-->

<!--2 типа обработки BigData - batch processing vs stream processing-->
<!--Framework:-->
<!--Stripe - латежная система-->
<!--Silhouette - аутентификатор-->
<!--play web framework - веб фрейворк-->
<!--slick - соединение с базой-->

<!--Library:-->
<!--Cats-->
<!--https://blog.maizy.ru/posts/scala-cats-summary-->
<!--https://habr.com/ru/company/raiffeisenbank/blog/448128/-->
