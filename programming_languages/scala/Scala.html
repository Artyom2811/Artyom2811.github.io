<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Scala</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>
<body>
<div><a href="../ProgrammingLanguages.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Scala(Scalable Language)</h1>

    <h4>Проработать</h4>
    <ol>
        <li><a href="https://docs.scala-lang.org/overviews/scala-book/futures.html">SCALA FUTURES</a></li>
        <li><a href="https://docs.scala-lang.org/tour/pattern-matching.html">PATTERN MATCHING</a></li>
        <li><a href="https://www.youtube.com/watch?v=1G7oNfP-PZs">Future и Promise</a></li>
        <li><a href="https://www.baeldung.com/scala/futures-promises">futures-promises</a></li>
        <li><a href="https://eax.me/scala-futures/">Перестаем бояться футур (futures) в Scala</a></li>
        <li><a href="https://eax.me/monads/">Собираемся с духом и перестаем бояться монад</a></li>
        <li><a href="https://habr.com/ru/post/209510/">Монады в Scala</a></li>
        <li><a href="https://habr.com/ru/post/233555/">Back to the Scala Future</a></li>
        <li><a href="https://www.youtube.com/watch?v=qdD-NuCRkzA">Scala Futures</a></li>
        <li><a href="https://www.youtube.com/watch?v=hGMndafDcc8">Options in Futures, how to unsuck them</a></li>
        <li><a href="https://xebia.com/blog/try-option-or-either/">Try, Option or Either?</a></li>
        <li><a href="https://habr.com/ru/company/jugru/blog/340178/">Моноиды, полугруппы и все-все-все</a></li>
        <li><a href="https://mageswaran1989.medium.com/null-in-scala-some-interesting-exploration-a7378dea0c77">null in Scala</a></li>
        <li><a href="https://habr.com/ru/post/354028/">Понимаем implicit'ы в Scala</a></li>
        <li><a href="https://habr.com/ru/post/329600/">Как использовать implicit'ы в Scala и сохранить рассудок</a></li>
        <li><a href="https://habr.com/ru/post/440900/">REST страсти по 200</a></li>
        <li><a href="https://apicrazy.com/2014/04/30/loops-in-scala-imperative-tailrecursive/">Loops in Scala (Imperative & Tail Recursive)</a></li>
        <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaErrorHandling">Play - Handling errors</a></li>
        <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaDependencyInjection">Play - Dependency Injection</a></li>
        <li><a href="https://www.playframework.com/documentation/2.8.x/SettingsLogger">Play - Configuring logging</a></li>
        <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaCsrf">Play - Protecting against Cross Site Request Forgery</a></li>
        <li><a href="https://www.playframework.com/documentation/2.8.x/ConfiguringHttps">Play - Configuring HTTPS</a></li>
        <li><a href="https://groz.github.io/scala/intro/futures/">Введение в Scala.</a></li>
        <li><a href="https://docs.scala-lang.org/ru/overviews/collections-2.13/overview.html">ИЗМЕНЯЕМЫЕ И НЕИЗМЕНЯЕМЫЕ КОЛЛЕКЦИИ</a></li>
        <li><a href="https://ru.education-wiki.com/9406244-scala-interview-questions">Scala Интервью Вопросы</a></li>
        <li><a href="https://twitter.github.io/scala_school/ru/index.html">Scala Школа!</a></li>
        <li>cats</li>
        <li><a href="https://temofeev.ru/info/articles/9-sovetov-po-ispolzovaniyu-biblioteki-cats-v-scala/">9 советов по использованию библиотеки Cats в Scala</a></li>
        <li>zio</li>
        <li>Type class vs case class</li>
    </ol>

    <div> Это многопарадигмальный язык программирования. Он поддерживает как объектно-ориентированный, так и
        функциональный язык программирования. Это работает для JVM (виртуальная машина Java).
    </div>

    <ol>Основные разделы:
        <li><a href="collections/Collections.html">Collections</a></li>
        <li><a href="collections/Collections.html">Collections</a></li>
        <li><a href="for_comprehension/Collections.html">ForComprehension</a></li>
    </ol>

    <ol>Основной stack scala:
        <li>SBT(scala build tool) - система сборки проекта</li>
        <li>Play Framework - MVC фреймворк.</li>
        <li>Slick - Библиотека работы с БД (http://scala-slick.org/)</li>
        <li>Quill - Библиотека работы с БД (https://getquill.io/)</li>
        <li>Silhouette - Библиотека для аутентификации</li>
    </ol>

    <p>Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется как
        вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в
        процедурном программировании). На практике отличие математической функции от понятия «функции» в
        императивном программировании заключается в том, что императивные функции могут опираться не только
        на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные
        эффекты и менять состояние внешних переменных. Таким образом, в императивном программировании при
        вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма,
        можно получить разные данные на выходе из-за влияния на функцию состояния переменных. А в функциональном
        языке при вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные
        данные зависят только от входных. Это позволяет средам выполнения программ на функциональных языках кешировать
        результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо
        дополнительных действий со стороны программиста
    </p>
    <p>Side effect - это действие, которое выходит за границы функции.</p>
    <div>Implicit(Неявное)
        <ol>
            <li>Неявные параметры - параметры соответствующих типов которые будут переданы в качестве параметров.</li>
            <li>Неявные преобразования - позволяют автоматически преобразовать значение одного типа к другому.
                <pre>
case class A(i: Int)
case class B(i: Int)

implicit def aToB(a: A): B = B(a.i)

val a = A(1)
val b: B = a
println(b)
        </pre>
            </li>
            <li>Неявные классы</li>
        </ol>
        <ol>Пустые типы в scala:
            <li>Nothing - - это самый нижний тип. Переменную с таким типом можно присвоить любое значение. Exception
                возвращает Nothing
            </li>
            <li>Null - trait который реализован в null</li>
            <li>null - наследник всех объектов, но не наследник всех примитивов.</li>
            <li>Nil - представление пустых списков</li>
            <li>Unit или () - Эквивалент Java void, который используется для функций, не имеющих возвращаемого типа
            </li>
            <li>None - Использует Option</li>
        </ol>
    </div>

    <p>Option - необходим как обёртка над значением(Some()) или его отсутствие(None). И можно без риска использовать
        функции высшего порядка над переменной(map и тд.)
    </p>
    <p>Either[Error, T] - это тип, который содержит либо значение, либо исключение.</p>
    <p>Try[T] - это подмножество "Either[Error, T]", который содержит либо значение, либо исключение.
        Может быть мутирован в Option.
    </p>
    <h3>Способы вызова функции:</h3>
    <p>
        Вызов по значения - def callByValue(x: Int) = {} - переменная будет получена один раз и переиспользоваться в
        методе
    </p>
    <p>
        Вызов по имени - def callByName(x: => Int) = {} - переменная будет переполучаться при каждом вызове x в методе
    </p>
    <p>
        <b>Функция высшего порядка(Higher-order function)</b> - функция/метод которая принимающая в качестве аргументов
        другие функции
        или возвращающая другую функцию в качестве результата. Также в нее можно передать метод.
    </p>
    <pre>С использование функции
def f(x: Int) = x + 3

def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(f, 7))
    </pre>
    <pre>С использованием анонимной функции
def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(_ + 3, 7))
    </pre>
    <ul>Чистые функции - функции, которые не имеют побочных эффектов ввода-вывода и памяти
        <li>если результат чистой функции не используется, её вызов может быть удалён без вреда для других выражений
        </li>
        <li>результат вызова чистой функции может быть мемоизирован, то есть сохранён в таблице значений вместе с
            аргументами вызова
        </li>
        <li>если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их вычисления можно
            поменять или распараллеливать (говоря иначе, вычисление чистых функций удовлетворяет принципам
            потокобезопасности)
        </li>
    </ul>
    <ul>Immutable Object - называется объект, состояние которого не может быть изменено после создания.
        <li>Блокировка для многопоточности больше не является проблемой: если данные не изменяются, нет необходимости в
            какой-либо блокировке, чтобы синхронизировать разные потоки
        </li>
        <li>хранение (persistence) — ещё один ключевой концепт, который мы рассмотрим позже, становится проще</li>
        <li>копирование возможно за константное время, потому что этот процесс становится лишь вопросом создания новой
            ссылки на уже существующий экземпляр структуры данных
        </li>
    </ul>
    <p>Недостатки Immutable - используется много Heap(молодой) памяти, так как часто удаляются уже использованные
        объекты.</p>
    <p>Как посчитать количество одинаковых элементов в List?</p>
    <p>-> - оператор для создания tuple и Map</p>
    <pre>
val foo = List("r", "r",  "s",  "s",  "x",  "x").toStream.groupBy(i => i).mapValues(_.size)
    </pre>
    <p>Exception - в Scala исключения действуют так же как и в JAVA, но тут нет "checked"(то есть компилятор их не
        проверяет) исключений.
        Выражение trow имеет специальный тип Nothing.
    </p>
    <p>Error - не обрабатываемые исключения тк после из возникновений нет гарантий что программа будет выполняться
        корректно.</p>
    <p>Каррирование(Currying) - частичный вызов функции(частичное применение), для дальнейшего использования.
    <pre>
def multiply(m: Int)(n: Int): Int = m * n
val timesTwo = multiply(2) _
timesTwo(3)
    </pre>
    </p>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>