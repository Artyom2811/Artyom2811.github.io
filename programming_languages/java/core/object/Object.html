<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Object</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>
<body>
<div><a href="../Core.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Object</h1>

    <h2>Проработать</h2>
    <ol>
        <li><a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/">Java hashCode() and equals() Methods</a></li>
        <li><a href="https://habr.com/ru/post/168195/">Разбираемся с hashCode() и equals()</a></li>
        <li><a href="https://javadevblog.com/klonirovanie-ob-ektov-v-java-primer-ispol-zovaniya-metoda-clone.html">Клонирование объектов в Java. Пример использования метода clone()</a></li>
        <li><a href="https://javarush.ru/groups/posts/1989-kontraktih-equals-i-hashcode-ili-kak-ono-vsje-tam">EqualsAndHashcode</a></li>
    </ol>

    <p>Object - суперкласс для всех классов в JAVA, кроме примитивов.</p>

    <h2>Методы:</h2>
    <ul>
        <li>boolean equals(Object obj) - определяет, равен ли один объект другому.</li>
        <li>int hashCode() - возвращает хеш-код, связанный с вызывающим объектом.</li>
        <li>String toString() - возвращает строку, описывающий объект.</li>
        <li>Class<?> getClass() - получает класс объекта во время выполнения.</li>
        <li>void wait() - ожидает другого потока выполнения.</li>
        <li>void wait(long millis) - ожидает другого потока выполнения.</li>
        <li>void wait(long millis, int nanos) - ожидает другого потока выполнения.</li>
        <li>void notify() - возобновляет выполнение потока, который ожидает вызывающего объекта.</li>
        <li>void notifyAll() - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта.</li>
        <li>Object clone() - создаёт новый объект, не отличающий от клонируемого. Для использования, необходимо
        реализовать метод clone() интерфейса Clonable(иначе не работает). Но не рекомендуется! Для клонирования
            необходимо объявить конструктор копирования следующим образом:
            <pre>
class Color{
    public Color(){ /* ... */ } // default constructor
    public Color(Color c){
        this.name = c.name; // copy all attributes
    }
    // other methods
}
            </pre>
        </li>
        <li>void finalize() - вызывается перед удалением неиспользуемого объекта.</li>
    </ul>
    <h2>Правила переопределения equals():</h2>

    <ul>
        <li>Рефлексивность - a.equals(a).</li>
        <li>Симетричность - a=b, b=a</li>
        <li>Транзитивность - a=b, b=c, a=c.</li>
        <li>Согласованость - каждый раз одинаковый результат.</li>
        <li>Проверка на NULL - если NULL вернуть false.</li>
    </ul>

    <h2>Пример equals(Object obj):</h2>
    <div>
        public boolean equals(Object obj) {<br>
        if (obj == this) {<br>
        return true;<br>
        }<br>
        if (obj == null || obj.getClass() != this.getClass()) {<br>
        return false;<br>
        }<br>
        <br>
        Person guest = (Person) obj;<br>
        return a == guest.a && b.equals(guest.b) && c.equals(guest.c) //Если ссылочная переменная то equals()<br>
        }<br>
    </div>

    <h2>Пример hashcode():</h2>
    public int hashCode() {<br>
    return Objects.hash(a, b, c);<br>
    }

    <h2>Договор между equals() и hashcode():</h2>
    <ul>
        <li>Если два объекта равны, то они должны иметь один и тот же хэш-код.</li>
        <li>Если два объекта не равны, то они могут иметь или не иметь один и тот же хэш-код(коллизия).</li>
        <li>В обоих метода использовать одинаковые поля.</li>
    </ul>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>