<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Concurrency</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../JAVA.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Concurrency</h1>

    <h2>Проработать:</h2>
    <ol>
        <li><a href="https://www.youtube.com/watch?v=s032s29-NUU">Deadlock - Concurrency #1 - Advanced Java</a></li>
        <li><a href="https://javarush.ru/quests/lectures/questmultithreading.level06.lecture06">undefined Мютекс и монитор</a></li>
        <li><a href="http://www.javenue.info/post/87">Синхронизированный метод и блок в Java (synchronized method vs block)</a></li>
        <li><a href="https://javarush.ru/groups/posts/1055-sinkhronizacija-potokov-blokirovka-obhhekta-i-blokirovka-klassa">Синхронизация потоков, блокировка объекта и блокировка класса</a></li>
        <li><a href="https://javadevblog.com/java-lock-teoriya-i-primer-ispol-zovaniya-concurrency-lock.html">Java Lock API. Теория и пример использования</a></li>
        <li><a href="https://tproger.ru/translations/10-java-multithread-practices/">10 советов по многопоточному программированию на Java</a></li>
        <li><a href="https://habr.com/ru/post/164487/">Многопоточность в Java</a></li>
        <li><a href="https://www.examclouds.com/java/java-core-russian/thread-syncronization">Синхронизация потоков</a></li>
        <li><a href="https://habr.com/ru/post/143237/">А как же всё-таки работает многопоточность? Часть I: синхронизация</a></li>
        <li><a href="https://habr.com/ru/company/luxoft/blog/157273/">Обзор java.util.concurrent.*</a></li>
        <li><a href="https://metanit.com/java/tutorial/8.3.php">Синхронизация потоков. Оператор synchronized</a></li>
        <li><a href="https://javarush.ru/groups/posts/1998-upravlenie-potokami-metodih-volatile-i-yield">Управление потоками. Ключевое слово volatile и метод yield()</a></li>
        <li><a href="https://ru.stackoverflow.com/questions/661805/%D0%A7%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BC%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80-%D0%BC%D1%8C%D1%8E%D1%82%D0%B5%D0%BA%D1%81-%D0%B8-%D1%81%D0%B5%D0%BC%D0%B0%D1%84%D0%BE%D1%80-%D0%AD%D1%82%D0%BE-%D0%BE%D0%B4%D0%BD%D0%BE-%D0%B8-%D1%82%D0%BE%D0%B6%D0%B5-%D0%B8%D0%BB%D0%B8-%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D0%B5-%D0%B2%D0%B5%D1%89%D0%B8">Что такое монитор, мьютекс и семафор? Это одно и тоже или разные вещи?</a></li>
        <li><a href="https://habr.com/ru/post/108016/">5 вещей, которых вы не знали о многопоточности</a></li>
        <li><a href="http://skipy.ru/technics/synchronization.html">Синхронизация потоков</a></li>
    </ol>

    <h2>Основные разделы:</h2>
    <ul>
        <li><a href="callable/Callable.html">Callable</a></li>
        <li><a href="concurrent/Concurrent.html">Concurrent</a></li>
        <li><a href="thread/Thread.html">Thread</a></li>
    </ul>

    <h2>Ошибки многопоточности:</h2>
    <h3>Race condition(состояние гонки)</h3>
    <p>Race condition - ошибка проектирования многопоточной системы или приложения, при которой работа системы или
        приложения зависит от того, в каком порядке выполняются части кода.
    </p>

    <h3>Deadlock(взаимная блокировка)</h3>
    <p>Deadlock(взаимная блокировка) - ошибка, которая происходит когда нити имеют циклическую зависимость от
        пары синхронизированных объектов. Представьте, что одна нить входит в монитор объекта A, а другая —
        объекта B. Если нить в объекте A пытается вызвать любой синхронизированный метод объекта B, а объект A в
        то же самое время пытается вызвать любой синхронизированный метод объекта A, то нити застрянут в процессе
        ожидания.
    </p>
    <p><b>Типы Deadlock:</b></p>
    <h4>Взаимная блокировка порядка синхронизации</h4>
    <pre>
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
}
    </pre>

    <p>Способ решения - можно всегда делать блокировку в порядке Id объектов. И тогда всегда будет сначала
        блокироваться первый объект. И если он уже занят, будет ожидания его освобождения.</p>
    <pre>
private void doTransfer(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException {
	if (fromAcct.getBalance().compareTo(amount) < 0)
		throw new InsufficientFundsException();
	else {
		fromAcct.debit(amount);
		toAcct.credit(amount);
	}
}
public void transferMoney(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException {
	int fromId= fromAcct.getId();
	int toId = fromAcct.getId();
	if (fromId < toId) {
		synchronized (fromAcct) {
			synchronized (toAcct) {
				doTransfer(fromAcct, toAcct, amount)}
			}
		}
	} else  {
		synchronized (toAcct) {
			synchronized (fromAcct) {
				doTransfer(fromAcct, toAcct, amount)}
			}
		}
	}
}
    </pre>

    <h4>Взаимная блокировка между объектами</h4>
    <pre>
class Plane {
	private Point location, destination;
	private final Dispatcher dispatcher;

	public Plane(Dispatcher dispatcher) {
		this.dispatcher = dispatcher;
	}
	public synchronized Point getLocation() {
		return location;
	}
	public synchronized void setLocation(Point location) {
		this.location = location;
		if (location.equals(destination))
		dispatcher.requestLanding(this);
	}
}

class Dispatcher {
	private final Set&lt;Plane&gt; planes;
	private final Set&lt;Plane&gt; planesPendingLanding;

	public Dispatcher() {
		planes = new HashSet&lt;Plane>();
		planesPendingLanding = new HashSet&lt;Plane&gt;();
	}
	public synchronized void requestLanding(Plane plane) {
		planesPendingLanding.add(plane);
	}
	public synchronized Image getMap() {
		Image image = new Image();
		for (Plane plane : planes)
			image.drawMarker(plane.getLocation());
		return image;
	}
}
    </pre>
    <p>В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может
        возникнуть взаимная блокировка. То есть, будут вызваны методы, getMap и setLocation, которые займут мониторы
        экземпляров Dispatcher и Plane соответственно. Затем метод getMap вызовет plane.getLocation (в частности для
        экземпляра Plane, который в данный момент занят), который будет ждать освобождения монитора для каждого из
        экземпляров Plane. В то же время в методе setLocation будет вызван dispatcher.requestLanding, при этом монитор
        экземпляра Dispatcher остается занят рисованием карты. Результат – взаимная блокировка.
    </p>
    <p>Можно исправить изменив методы:</p>
    <pre>
public void setLocation(Point location) {
	boolean reachedDestination;
	synchronized(this){
		this.location = location;
		reachedDestination = location.equals(destination);
	}
	if (reachedDestination)
		dispatcher.requestLanding(this);
}
………………………………………………………………………………
public Image getMap() {
	Set&lt;Plane&gt; copy;
	synchronized(this){
		copy = new HashSet&lt;Plane&gt;( planes);
	}
	Image image = new Image();
	for (Plane plane : copy)
		image.drawMarker(plane.getLocation());
	return image;
}
    </pre>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>