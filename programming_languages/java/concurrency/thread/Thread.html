<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Thread</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>
<body>
<div><a href="../Concurrency.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Thread(Поток)</h1>

    <h2>Проработать:</h2>
    <ol>
        <li>Что монитор для статик метода?</li>
        <li>Executer Servise</li>
        <li>Требования для объекта синхронизации.</li>
    </ol>

    <h2>Что это:</h2>
    <p>Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.
        Чаще всего одна программа состоит из одного процесса, но бывают и исключения (например, браузер
        Chrome создает отдельный процесс для каждой вкладки, что дает ему некоторые преимущества, вроде
        независимости вкладок друг от друга). Процессы изолированы друг от друга, поэтому прямой доступ к
        памяти чужого процесса невозможен (взаимодействие между процессами осуществляется с помощью специальных
        средств).
    </p>

    <h2>Способы создания потоков:</h2>
    <ol>
        <li>Создать класс с имплементацией Runnable, передать его в конструктор класса Thread и вызвать метод start().
            Этот интерфейс содержит метод run(), который будет выполняться в новом потоке.
            Поток закончит выполнение, когда завершится его метод run().
        </li>
        <li>Наследоваться от класса Thread и переопределить его метод run().</li>
    </ol>

    <h2>Volatile</h2>
    <p>volatile - ключевое слово для переменной</p>
    <ol>
        <li>Она всегда будет атомарно читаться и записываться. Даже если это 64-битные double или long.</li>
        <li>Java-машина не будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными
            копиями исключена.
        </li>
    </ol>

    <h2>synchronized</h2>
    <p>Synchronized - это ключевое слово, которое позволяет заблокировать доступ к методу или части кода, если его
        уже использует другой поток.
    </p>
    <div>Может использоваться:
        <ol>
            <li>Для блока кода - если не нужно синхронизировать весь метод.
                <pre>
private Object key = new Object();

synchronized (key) {
    System.out.println("Hi I'm synchronized block!");
}
                </pre>
            </li>
            <li>Для метода.
                <pre>
synchronized void myMethod() {
    System.out.println("Hi I'm synchronized method!");
}
                </pre>
                <p>В качестве параметра synchronized для метода передается ссылка на объект - this</p>
                <p>Можно воспринимать так:</p>
                <pre>
void myMethod() {
    synchronized(this) {
      System.out.println("Hi I'm synchronized method!");
    }
}
            </pre>
                <p>Для статического метода передается .class:</p>
                <pre>
static void myMethod() {
    synchronized(MyObject.class) {
      System.out.println("Hi I'm synchronized method!");
    }
}
                </pre>
            </li>
        </ol>
        <p>Минус synchronized - другие потоки вынуждены ждать, пока нужный объект или метод освободится "bottle neck".</p>
    </div>

    <h2>Вопросы:</h2>
    <p>Разница start() и run() - start в новом потоке, run в том же потоке.</p>
    <p>Thread daemon - поток, который умирает при окончании всех не daemon потоков.</p>
    <p>Монитор - это специальный объект, который следит за "состоянием" метода или объекта.
        Он смотрит, "занят" он или "свободен" в данный момент.
    </p>
    <p>Атомарный - значит "неделимый" - в том смысле, что операция может быть завершена одним потоком, и другой
        не  может в ней ничего "напортить".
    </p>
    <p>Thread.join - приостанавливает поток до завершения другого потока.
    </p>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>