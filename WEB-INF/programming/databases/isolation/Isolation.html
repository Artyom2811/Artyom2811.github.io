<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Isolation</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../Databases.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Isolation</h1>

    <section>
        <h2>Проблемы параллельного доступа с использованием транзакций</h2>
    </section>

    <section>
        <h2>Lost update</h2>
        <p>Lost update - ситуация, когда при одновременном изменении одного блока данных разными
            транзакциями одно из изменений теряется.
        </p>
        <table class="wikitable">
            <tbody>
            <tr>
                <th>Транзакция 1</th>
                <th>Транзакция 2</th>
            </tr>
            <tr>
                <td><code>UPDATE tbl1 SET f2=f2+20 WHERE f1=1;</code></td>
                <td><code>UPDATE tbl1 SET f2=f2+25 WHERE f1=1;</code></td>
            </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Dirty read</h2>
        <p>Dirty read - чтение данных, добавленных или изменённых транзакцией, которая впоследствии не
            подтвердится (откатится).
        </p>
        <table class="wikitable">
            <tbody>
            <tr>
                <th>Транзакция 1</th>
                <th>Транзакция 2</th>
            </tr>
            <tr>
                <td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td>
            </tr>
            <tr>
                <td><code>ROLLBACK WORK;</code></td>
                <td></td>
            </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Non-repeatable read</h2>
        <p>Non-repeatable read - ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные
            данные оказываются изменёнными.
        </p>
        <table class="wikitable">
            <tbody>
            <tr>
                <th>Транзакция 1</th>
                <th>Транзакция 2</th>
            </tr>
            <tr>
                <td></td>
                <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td>
            </tr>
            <tr>
                <td><code>UPDATE tbl1 SET f2=f2+1 WHERE f1=1;</code></td>
                <td></td>
            </tr>
            <tr>
                <td><code>COMMIT;</code>
                </td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td><code>SELECT f2 FROM tbl1 WHERE f1=1;</code></td>
            </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Phantom reads</h2>
        <p>Phantom reads - ситуация, когда при повторном чтении в рамках одной транзакции одна и та же
            выборка дает разные множества строк.
        </p>
        <table class="wikitable">
            <tbody>
            <tr>
                <th>Транзакция 1</th>
                <th>Транзакция 2</th>
            </tr>
            <tr>
                <td></td>
                <td><code>SELECT SUM(f2) FROM tbl1;</code></td>
            </tr>
            <tr>
                <td><code>INSERT INTO tbl1 (f1,f2) VALUES (15,20);</code></td>
                <td></td>
            </tr>
            <tr>
                <td><code>COMMIT;</code></td>
                <td></td>
            </tr>
            <tr>
                <td></td>
                <td><code>SELECT SUM(f2) FROM tbl1;</code></td>
            </tr>
            </tbody>
        </table>
    </section>

    <section>
        <h2>Уровни изоляции</h2>
    </section>

    <section>
        <h2>Read uncommitted(чтение незафиксированных данных)</h2>
        <p>Read uncommitted - гарантирует только отсутствие потерянных обновлений.
            Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение,
            определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только
            логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.
        </p>
        <p>Использовать: почти никогда. Только в очень специфичных сценариях, где нужна максимальная скорость,
            а ошибки допустимы(например, аналитика, где небольшие неточности не критичны).
        </p>
    </section>

    <section>
        <h2>Read committed(чтение фиксированных данных)</h2>
        <p>Read committed (чтение фиксированных данных) - Большинство промышленных СУБД, в частности,
            Microsoft SQL Server, PostgreSQL и Oracle, по умолчанию используют именно этот уровень. На этом
            уровне обеспечивается защита от чернового, «грязного» чтения, тем не менее, в процессе работы одной
            транзакции другая может быть успешно завершена и сделанные ею изменения зафиксированы. В итоге первая
            транзакция будет работать с другим набором данных. Реализация завершённого чтения может основываться
            на одном из двух подходов: блокировании или версионности.
        </p>

        <p>Использовать: это уровень по умолчанию в большинстве СУБД(например, Oracle, PostgreSQL). Подходит для
            большинства бизнес-приложений, где важнее производительность, чем идеальная консистентность.
        </p>

        <h3>Блокирование читаемых и изменяемых данных.</h3>
        <p>Заключается в том, что пишущая транзакция блокирует изменяемые данные для читающих транзакций,
            работающих на уровне read committed или более высоком, до своего завершения, препятствуя, таким
            образом, «грязному» чтению, а данные, блокируемые читающей транзакцией, освобождаются сразу
            после завершения операции SELECT (таким образом, ситуация «неповторяющегося чтения» может возникать
            на данном уровне изоляции).
        </p>

        <h3>Сохранение нескольких версий параллельно изменяемых строк.</h3>
        <p>При каждом изменении строки СУБД создаёт новую версию этой строки, с которой продолжает работать
            изменившая данные транзакция, в то время как любой другой «читающей» транзакции возвращается
            последняя зафиксированная версия. Преимущество такого подхода в том, что он обеспечивает
            бо́льшую
            скорость, так как предотвращает блокировки. Однако он требует, по сравнению с первым,
            существенно
            бо́льшего расхода оперативной памяти, которая тратится на хранение версий строк. Кроме того, при
            параллельном изменении данных несколькими транзакциями может создаться ситуация, когда несколько
            параллельных транзакций произведут несогласованные изменения одних и тех же данных (поскольку
            блокировки отсутствуют, ничто не помешает это сделать). Тогда та транзакция, которая
            зафиксируется
            первой, сохранит свои изменения в основной БД, а остальные параллельные транзакции окажется
            невозможно зафиксировать (так как это приведёт к потере обновления первой транзакции).
            Единственное,
            что может в такой ситуации СУБД — это откатить остальные транзакции и выдать сообщение об ошибке
            «Запись уже изменена».
            Конкретный способ реализации выбирается разработчиками СУБД, а в ряде случаев может
            настраиваться.
            Так, по умолчанию MS SQL использует блокировки, но (в версии 2005 и выше) при установке
            параметра
            READ_COMMITTED_SNAPSHOT базы данных переходит на стратегию версионности, Oracle исходно работает
            только по версионной схеме. В Informix можно предотвратить конфликты между читающими и пишущими
            транзакциями, установив параметр конфигурации USELASTCOMMITTED (начиная с версии 11.1), при этом
            читающая транзакция будет получать последние подтвержденные данные.
        </p>
    </section>

    <section>
        <h2>Repeatable read(повторяемость чтения)</h2>
        <p>Читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны.
            При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не
            окончена. Блокировки в разделяющем режиме применяются ко всем данным, считываемым любой инструкцией
            транзакции, и сохраняются до её завершения. Это запрещает другим транзакциям изменять строки, которые
            были считаны незавершённой транзакцией. Однако другие транзакции могут вставлять новые строки,
            соответствующие условиям поиска инструкций, содержащихся в текущей транзакции. При повторном запуске
            инструкции текущей транзакцией будут извлечены новые строки, что приведёт к фантомному чтению. Учитывая
            то, что разделяющие блокировки сохраняются до завершения транзакции, а не снимаются в конце каждой
            инструкции, степень параллелизма ниже, чем при уровне изоляции READ COMMITTED. Поэтому пользоваться данным
            и более высокими уровнями транзакций без необходимости обычно не рекомендуется.
        </p>

        <p>Использовать: когда важно, чтобы данные в рамках одной транзакции оставались стабильными, например при
            проверке баланса на счёте перед списанием.
        </p>
    </section>

    <section>
        <h2>Serializable(упорядочиваемость)</h2>
        <p>Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется
            последовательно, как будто параллельных транзакций не существует. Только на этом уровне параллельные
            транзакции не подвержены эффекту «фантомного чтения».
        </p>

        <p>Использовать: когда критична полная консистентность, например:</p>
        <ul>
            <li>Банковские операции с балансами.</li>
            <li>Биллинг.</li>
            <li>Бронирование(чтобы два клиента не купили один билет).</li>
        </ul>
    </section>

    <section>
        <h2>Блокировка</h2>
        <p>Блокировки – это меры по предотвращению модификации данных в реляционной базе данных между временем их
            чтения, и временем их использования.
        </p>

        <h2>По логике реализации</h2>
        <h3>Пессимистическая блокировка</h3>
        <p>Пессимистичная стратегия подразумевает, что параллельные транзакции будут конфликтовать каждая друг с
            другом, и требует блокировки ресурсов после их чтения, а также ее снятия только после того,
            как приложение завершило использование данных.
        </p>

        <h3>Оптимистическая блокировка</h3>
        <p>Оптимистичные блокировки предполагают, что множество транзакций могут завершиться без влияния друг на друга,
            и таким образом могут выполняться без блокировок тех ресурсов, на которые они влияют. Перед коммитом,
            каждая транзакция проверяет, что ни одна другая транзакция не модифицировала ее данные(проверяя версию).
            Если проверка выявила конфликтующие модификации, транзакция, находящаяся в состоянии коммита, откатывается.
        </p>
    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>