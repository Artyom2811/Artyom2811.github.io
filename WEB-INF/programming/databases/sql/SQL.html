<!--html_style_version_1-->
<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>SQL</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>

<body>
<div><a href="../Databases.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>SQL</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://www.youtube.com/watch?v=rz6R9r-3V74">Внешний ключ и виды связей</a></li>
            <li><a href="http://www.yaklass.ru/materiali?chtid=511&mode=cht">Реляционная база данных и ее особенности.</a></li>
            <li><a href="https://habr.com/ru/company/otus/blog/461067/">Топ-65 вопросов по SQL</a></li>
            <li><a href="http://www.skillz.ru/dev/php/article-Obyasnenie_SQL_obedinenii_JOIN_INNER_OUTER.html">Объяснение SQL объединений JOIN: LEFT/RIGHT/INNER/OUTER</a></li>
            <li><a href="https://habr.com/ru/companies/tensor/articles/676784/">SQL HowTo: наперегонки со временем</a></li>
            <li><a href="https://habr.com/ru/companies/ozontech/articles/705912/">База по шардированию базы</a></li>
            <li><a href="https://habr.com/ru/articles/779598/">Рекомендации по ведению SQL-кода</a></li>
            <li><a href="https://habr.com/ru/companies/piter/articles/819423/">Книга: «Антипаттерны SQL. Как избежать ловушек при работе с базами данных»</a></li>
            <li><a href="https://habr.com/ru/articles/968532/">БД без боли: моя шпаргалка для собесов в Java. Часть 4</a></li>

            <li><a href="https://www.sqlzoo.net/wiki/SQL_Tutorial">SQLZoo</a></li>
            <li><a href="https://www.w3schools.com/sql/default.asp">W3Schools</a></li>
            <li><a href="https://mode.com/sql-tutorial">Mode Analytics SQL Tutorial</a></li>
            <li><a href="https://sqlbolt.com/">SQLBolt</a></li>
            <li><a href="https://leetcode.com/studyplan/top-sql-50/">LeetCode (раздел SQL)</a></li>
            <li><a href="https://habr.com/ru/companies/otus/articles/949468/">SQL против NoSQL: мифы и реальность</a></li>
        </ol>
    </div>

    <section>
        <h2>Основные разделы</h2>
        <h3>Общее</h3>
        <ul>
            <li><a href="link_types/LinkTypes.html">Link Types</a></li>
            <li><a href="transactionLevels/TransactionLevels.html">TransactionLevels</a></li>
            <li><a href="normalization/Normalization.html">Нормализация(Normalization)</a></li>
            <li><a href="indexes/Indexes.html">Indexes</a></li>
            <li><a class="anchor" href="#databases">Базы данных</a></li>
            <li><a class="anchor" href="#restrictions">Ограничения в SQL</a></li>
            <li><a class="anchor" href="#planning">Планирование схемы таблицы</a></li>
            <li><a class="anchor" href="#basic_concepts">Основные понятия</a></li>
            <li><a class="anchor" href="#commands">Команды</a></li>
            <li><a class="anchor" href="#optimization">Оптимизация запросов</a></li>
            <li><a class="anchor" href="#injection">SQL-инъекции</a></li>
        </ul>
    </section>

    <section>
        <h3 id="databases">Базы данных</h3>
        <ul>
            <li><a href="databases/my_sql/MySql.html">MySql</a></li>
            <li><a href="databases/postgreSql/Postgre.html">Postgre</a></li>
            <li><a href="databases/h2/H2.html">H2</a></li>
            <li><a href="databases/sybase/Sybase.html">Sybase</a></li>
        </ul>
    </section>

    <section>
        <h2 id="restrictions">Ограничения в SQL</h2>
        <ul>
            <li>NOT NULL - столбец не может принимать значения NULL.</li>
            <li>PRIMARY KEY - для определения уникального указателя для каждой строки. Должен быть unique и not null.
                <ul>
                    <li>Гарантирует уникальность указанных полей.</li>
                    <li>Нельзя значение NULL.</li>
                    <li>Можно иметь только один PK.</li>
                    <li>Создает кластерный индекс.</li>
                    <li>Поддерживает авто инкремент.</li>
                    <li>Нельзя менять/удалять выбранные поля.</li>
                </ul>
            </li>
            <li>UNIQUE - в указанных столбцах уникальные значения.
                <ul>
                    <li>Гарантирует уникальность указанных полей.</li>
                    <li>Можно значение NULL.</li>
                    <li>Можно иметь несколько UNIQUE.</li>
                    <li>Создает не кластерный индекс.</li>
                    <li>Не поддерживает авто инкремент.</li>
                    <li>Нельзя менять/удалять выбранные поля.</li>
                </ul>
            </li>
            <li>DEFAULT - определяет значение по умолчанию для столбцов.</li>
            <li>FOREIGN KEY - это столбец или комбинация столбцов, которые используются для установления и
                обеспечения взаимосвязи между данными в двух таблицах.
            </li>
            <li>CHECK - используется для ограничения значений, которые могут быть помещены в столбец.</li>
        </ul>
    </section>

    <section>
        <h2 id="planning">Планирование схемы таблицы</h2>
        <ol>
            <li>Имя таблицы - lowercase единичном или множественно числе: user_admin, users.</li>
            <li>Необходимые колонки данных</li>
            <li>Колонка PK - обычно id. Если числовое можно автоинерементацию.</li>
            <li><a class="anchor" href="#reco_data_types">Типы данных</a></li>
            <li>Ограничения на колонки - UNIQUE, NOT NULL, MAX, MIN</li>
            <li>PRIMARY KEY - может быть только один. Нельзя null. По умолчанию имеет кластерный индекс.</li>
            <li>FOREIGN KEYS - можно применять как к PK, так и к обычным полям.</li>
            <li>UNIQUE поле/поля/связки полей - можно несколько, можно null(можно указать NOT NULL).</li>
            <li>TRIM - для строковых полей.</li>
            <li>INDEXES</li>
        </ol>
    </section>

    <section>
        <h2 id="basic_concepts">Основные понятия</h2>
        <h3>Дамп</h3>
        <p>Дамп(Dump) - файл, включающий в себя содержимое памяти базы данных.</p>
        <p>Используется для:</p>
        <ol>
            <li>Перенос данных на другой хостинг.</li>
            <li>Резервное копирование.</li>
        </ol>
    </section>

    <section>
        <h2 id="ddl">DDL(Data Definition Language)</h2>
        <ul>
            <li>CREATE</li>
            <li>DROP</li>
            <li>ALTER</li>
            <li>TRUNCATE</li>
            <li>COMMENT</li>
            <li>RENAME</li>
        </ul>
    </section>

    <section>
        <h2 id="dql">DQL(Data Query Language)</h2>

        <h3>SELECT</h3>
        <pre>
SELECT * FROM table1;
        </pre>
    </section>

    <section>
        <h2 id="dml">DML(Data Manipulation Language)</h2>
        <ul>
            <li>INSERT</li>
            <pre>
INSERT INTO table2 (user_id, phone_number) VALUE ('2','200');
            </pre>
            <li>UPDATE</li>
            <pre>
UPDATE table2 SET user_id='2', phone_number='200' WHERE phone_id='1';
            </pre>
            <li>DELETE</li>
            <li>LOCK</li>
            <li>CALL</li>
            <li>EXPLAIN PLAN</li>
        </ul>
    </section>

    <section>
        <h2 id="dcl">DCL(Data Control Language)</h2>
        <ul>
            <li>GRANT</li>
            <li>REVOKE</li>
        </ul>
    </section>

    <section>
        <h2 id="tcl">TCL(Transaction Control Language)</h2>
        <ul>
            <li>COMMIT</li>
            <li>ROLLBACK</li>
            <li>SAVEPOINT</li>
            <li>SET TRANSACTION</li>
        </ul>
    </section>

    <section>
        <h2 id="commands">Команды</h2>
        <ol>
            <li>WHERE - ограничивающее команда для SELECT, UPDATE, DELETE. Оно выполняется до того, как будет получен
                результат операции.
            </li>
            <li>LIKE - оператор для поиска по шаблону в строковых полях. Используется в WHERE. Операция like тяжелая тк
                предполагает чтение всей колонки в таблице. Желательна только в небольших таблицах.
            </li>
            <li>GROUP BY - используется для группировки данных.</li>
            <pre>
SELECT country, COUNT(*) AS n_companies
FROM companies
GROUP BY country
            </pre>
            <li>HAVING - фильтрующее выражение. Работает с командой GROUP BY(для результатов агрегированных функций).</li>
            <pre>
SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) > 5;
            </pre>

            <li>Виды Joins:
                <ul>
                    <li>INNER JOIN - общее</li>
                    <li>LEFT JOIN - левое и общее. Если не будет совпадения, правая часть будет null.</li>
                    <li>RIGHT JOIN - правое и общее. Если не будет совпадения, левая часть будет null.</li>
                    <li>FULL OUTER - выбирает не только записи с совпадающими значениями в этих столбцах, но и все
                        оставшиеся строки из обеих таблиц.
                    </li>
                    <li>CROSS(декартова произведения) - не общее</li>
                </ul>
            </li>
            <li>UNION - объединяет таблицы с одинаковыми полями и значением.</li>
            <li>UNION ALL - как UNION, но включает дубликаты.</li>
        </ol>
    </section>

    <section>
        <h2 id="optimization">Оптимизация запросов</h2>
        <ol>
            <li>Проверить план запроса</li>
            <li>Можно отключить планировщик запросов</li>
            <li>Использовать индексы</li>
            <li>Кэширование</li>
            <li>Партиционирование - разбивает таблицу на логические части внутри одно базы или сервера(пример: по месяцам).</li>
            <li>Шардирование - распределяет данные между разными независимыми серверами(шардами). Это сложнее по мощнее
                партиций.
            </li>
            <li>Репликация</li>
            <li>Batch-запросы - вместо тысяч отдельных INSERT.</li>
            <li>Нормализация/Денормализация - для чтения часто денормализуют таблицы или используют материализованные
                представления. Для записи — наоборот, нормализуют.</li>
            <li>Типы данных - использовать точные типы (INT вместо BIGINT, CHAR(2) вместо VARCHAR(255)), это экономит
                память и ускоряет сравнения.
            </li>
            <li>Скрипт должен идти по мере увеличения размера таблиц.</li>
            <pre>
Select *
From A a --100 записей
INNER JOIN B b ON a.c = b.c --1000 записей
INNER JOIN C c ON b.d = c.d --10000 записей
            </pre>
            <li>Фильтровать как можно раньше для уменьшения размеров обрабатываемых данных.</li>
        </ol>
    </section>

    <section>
        <h2 id="functions">Functions</h2>
        <h3>String Functions</h3>

        <h3>Numeric Functions</h3>
        
        <h3>Date Functions</h3>
        <ol>
            <li>YEAR - получить год из DATE.</li>
        </ol>
    </section>

    <section>
        <h2 id="tips">Советы</h2>
        <h3>Создание таблицы:</h3>
        <p>Если есть хоть одно unique поле - оно будет гарантировать что вся запись уникальна.</p>
    </section>

    <section>
        <h2 id="injection">SQL-инъекции</h2>
        <p>SQL-инъекция — это попытка изменить запрос к базе данных. Ввести ее можно через форму или ссылку, которая
            передает параметры методом GET.
        </p>
        <h3>Как защититься</h3>
        <p>В JAVA EE нужно использовать "PreparedStatement".</p>
    </section>

    <section>
        <h2 id="data_types">Рекомендуемые типы данных</h2>
        <h3>CHAR()</h3>
        <p>CHAR() - символьная переменная ТОЛЬКО(не больше, не меньше) заданного размера.</p>

        <h3>VARCHAR()</h3>
        <p>VARCHAR() - символьная переменная до(можно меньше) заданного размера.</p>
    </section>

    <section>
        <h2 id="reco_data_types">Рекомендуемые типы данных</h2>
        <h3>Email</h3>
        <p>VARCHAR(256)</p>

        <h3>Phone number</h3>
        <p>VARCHAR(15)</p>

        <h3>Bcrypt hashed</h3>
        <p>VARCHAR(60)</p>
    </section>

    <section>
        <h2>Переименование колонки в рабочем сервисе</h2>

        <h3>1. Убедись, что колонку не используют:</h3>
        <ul>
            <li>В представлениях (VIEW)</li>
            <li>В процедурах/триггерах</li>
            <li>В SQL-запросах на бэкенде</li>
            <li>В внешнем коде(Java, Python, Node.js)</li>
            <li>В BI-отчётах(Power BI, Tableau и др.)</li>
        </ul>

        <h3>2. Создай новую колонку с нужным именем:</h3>
        <pre>
ALTER TABLE users ADD COLUMN full_name VARCHAR(255);
UPDATE users SET full_name = fullname;
        </pre>

        <h3>3. Плавно переведи код на новую колонку</h3>
        <ul>
            <li>SQL-запросы</li>
            <li>Приложение</li>
            <li>Тесты</li>
        </ul>

        <h3>4. Удаление старой колонки (по желанию)</h3>
        <p>Когда точно убедишься, что fullname больше нигде не используется:</p>
        <pre>
ALTER TABLE users DROP COLUMN fullname;
        </pre>


    </section>

    <section>
        <h3>DELETE vs TRUNCATE:</h3>
        <ul>
            <li>TRUNCATE не может использовать WHERE.</li>
            <li>TRUNCATE быстрее и использует меньше системных ресурсов и практически не пишет лог транзакции.</li>
            <li>TRUNCATE после использования, откат (rollback) невозможен.</li>
            <li>TRUNCATE обнуляет счетчик, уникальности новых записей.</li>
        </ul>
    </section>

    <section>
        <h2>Процедуры и функции</h2>
        <p>Процедуры в отличие от функций не возвращают значения.</p>
    </section>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>