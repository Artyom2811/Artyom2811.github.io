<!--html_style_version_1-->
<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Class</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>
<body>
<div><a href="../Core.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Class</h1>

    <div class="todo">
        <h2>Проработать:</h2>
        <ol>
            <li><a href="https://javarush.ru/groups/posts/vidy-vlozhennyh-klassov">Классы, виды вложенных классов с примерами</a></li>
            <li><a href="https://javarush.com/groups/posts/2181-vlozhennihe-vnutrennie-klassih">Вложенные внутренние классы или Inner Class в Java</a></li>
            <li><a href="https://www.youtube.com/watch?v=10R_2-2HIX0">Анонимный класс (прокачанная Java)</a></li>
        </ol>
    </div>

    <section>
        <h2>Основные разделы</h2>
        <h3>Виды классов</h3>
        <ul>
            <li><a class="anchor" href="#class">Class</a></li>
            <li><a class="anchor" href="#abstractClass">Абстрактный класс(Abstract Class)</a></li>
            <li><a class="anchor" href="#record">Record</a></li>
            <li><a class="anchor" href="#inner">Внутренние классы</a></li>
            <li><a class="anchor" href="#interface">Интерфейс(Interface)</a></li>
            <li><a class="anchor" href="#enum">Enum(Перечисления)</a></li>
        </ul>

        <h3>О классах</h3>
        <ul>
            <li><a class="anchor" href="#classParts">Части класса</a></li>
            <li><a class="anchor" href="#initializationOrder">Порядок инициализации класса</a></li>
            <li><a class="anchor" href="#sealed">Sealed классы</a></li>
        </ul>
    </section>

    <section>
        <h2 id="class">Class</h2>
        <p>Class - обычный класс для создания объектов.</p>
    </section>

    <section>
        <h2 id="abstractClass">Абстрактный класс(Abstract Class)</h2>
        <p>Абстрактный класс(Abstract Class) - Для описания того из чего нельзя создать объект(например мебель).
            Могут иметь абстракт методы и реализации. Наследование возможно только от одного класса.
        </p>
    </section>

    <section>
        <h2 id="record">Record(since v.14)</h2>
        <p>Record - immutable класс для хранения записей.</p>
        <p>Не может использовать extends, но может имплементировать implements.</p>
        <pre>
record Point(int x, int y) { }
        </pre>

        <h3>Описание</h3>
        <ul>
            <li>Авто создание конструктора для всех полей.</li>
            <li>Авто создание getters для всех полей, но без префикса get.</li>
            <li>Авто реализация метода equals.</li>
            <li>Авто реализация метода hashCode.</li>
            <li>Авто реализация метода toString.</li>
            <li>Можно добавлять статические поля и методы.</li>
        </ul>

        <p>Можно описывать конструктор вручную</p>
        <pre>
public Person(String name) {
    this(name, "Unknown");
}
        </pre>
    </section>

    <section>
        <h2 id="inner">Внутренние классы</h2>
        <p>Примечание - при создании нескольких классов в одном файле. С доступом public может быть
            только один. Тот который соответствует имени файла. Или ошибка компиляции.
        </p>

        <h3>Nested Inner classes(вложенные внутренние классы)</h3>
        <p>Создание объекта: Outer.Inner inner = new Outer().new Inner();</p>

        <h3>Static Nested classes or Member of outer class (статические вложенные классы)</h3>

        <h3>Anonymous Inner classes (анонимные классы)</h3>
        <pre>
interface AnimalActions {
    void eat();
}

AnimalActions animal = new AnimalActions() {
    @Override
    public void eat() {
        System.out.println("Animal %s eating...");
    }

};
animal.eat();
        </pre>

        <h3>Method Local Inner classes (внутренние классы в локальном методе)</h3>
    </section>

    <section>
        <h2 id="interface">Интерфейс(Interface)</h2>
        <p>Интерфейс(Interface) - специальный класс-контракт для добавления функционала в другие классы.</p>
        <ul>
            <li>Может иметь default methods(since v.8).</li>
            <li>Может иметь private methods(since v.9).</li>
            <li>Поля только public static final.</li>
            <li>Возможно имплементировать несколько интерфейсов.</li>
        </ul>
    </section>

    <section>
        <h2 id="enum">Enum(Перечисления)</h2>
        <p>Enum(перечисление) - это набор логически связанных констант именованных констант. Все константы пишутся
            большими буквами.</p>

        <h3>Возможности:</h3>
        <ol>
            <li>Может иметь конструктор(только private).</li>
            <li>Может иметь методы, в том числе скрытые и абстрактные.</li>
            <li>Может переопределять общий метод описанный в Enum в отдельных константах.</li>
            <li>Может реализовывать интерфейс.</li>
            <li>Можно использовать в операторе switch.</li>
        </ol>

        <h3>Методы</h3>
        <ol>
            <li>values() - возвращает массив, содержащий список всех констант перечисления.</li>
            <li>valueOf() - возвращает константу перечисления, значение которой передается строкой при вызове.</li>
            <li>equals() - сравнивает эквивалентность.</li>
        </ol>

        <h3>Примеры</h3>
        <h4>Пример создания простого Enum</h4>
        <pre>
enum Cat {
    LEOPARD, PUMA, LION, TIGER, MANUL
}
        </pre>

        <h4>Пример использования</h4>
        <pre>
Cat a = Cat.PUMA;
        </pre>

        <h4>Пример создания Enum c полем и переопределенным методом в отдельной константе</h4>
        <pre>
enum SideOfWorld {
    NORTH("up") {
        void findTheBoss() {
            System.out.println("Santa is here!");
        }
    },
    SOUTH("down"),
    EAST("left"),
    WEST("right");

    private String direction;

    SideOfWorld(String direction) {
        this.direction = direction;
    }

    public String getDirection() {
        return direction;
    }

    void findTheBoss() {
        System.out.println("There is nobody!");
    }
        </pre>

        <h4>Пример использования</h4>
        <pre>
SideOfWorld sow = SideOfWorld.NORTH;
SideOfWorld sow1 = SideOfWorld.SOUTH;
sow.findTheBoss();
sow1.findTheBoss();
        </pre>
    </section>

    <section>
        <h2 id="classParts">Части класса</h2>
        <ol>
            <li>Импорты</li>
            <li>Аннотации</li>
            <li>Поля</li>
            <li>Методы</li>
            <li>Конструкторы</li>
            <li>Объекты</li>
            <li>Блок инициализации - блок кода внутри класса, который выполняется каждый раз при создании нового
                экземпляра класса. Используется для инициализации нестатических переменных. В них можно вызывать
                методы.
            </li>
            <li>Статический Блок инициализации - - отличается словом static. Используется для инициализации статических
                переменных. В них можно выполнять методы.
            </li>
            <li>Внутренние классы.</li>
        </ol>
    </section>

    <section>
        <h2 id="initializationOrder">Порядок инициализации класса</h2>
        <ol>
            <li>Статические блоки и статические поля в порядке объявления суперкласса(А)</li>
            <li>Статические блоки и статические поля в порядке объявления подкласса(В)</li>
            <li>Не статические блоки и не статические поля в порядке объявления суперкласса(А)</li>
            <li>Конструктор суперкласса(А)</li>
            <li>Не статические блоки и не статические поля в порядке объявления подкласса(B)</li>
            <li>Конструктор подкласса(B)</li>
        </ol>

        <h3>Пример</h3>
        <ol>
            <li>static field parent</li>
            <li>static { } parent</li>
            <li>static field child</li>
            <li>static { } сhild</li>
            <li>non static field parent</li>
            <li>non static { } parent</li>
            <li>constructor parent</li>
            <li>non static field child</li>
            <li>non static { } child</li>
            <li>constructor child</li>
        </ol>
    </section>

    <section>
        <h2 id="sealed">Sealed классы/интерфейсы</h2>
        <p>Модификатор final в классе не позволяет никому расширить его. Ключевое слово sealed позволяет расширить
            класс, но разрешить это только для указанных классов.
        </p>

        <pre>
public sealed class Vehicle permits Bicycle, Car {...}
//and use it
public final class Bicycle extends Vehicle {...}
        </pre>

        <p>Ограничения</p>
        <ol>
            <li>Разрешенные подклассы должны быть доступны запечатанному классу во время компиляции.</li>
            <li>Разрешенные подклассы должны напрямую расширять запечатанный класс</li>
            <li>Разрешенные подклассы должны иметь один из следующих модификаторов:final, sealed, non-sealed</li>
            <li>Разрешенные подклассы должны находиться в одном Java модуле.</li>
        </ol>
    </section>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>