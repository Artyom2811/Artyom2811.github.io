<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Synchronization</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../Concurrency.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Synchronization</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://javarush.com/groups/posts/1994-sinkhronizacija-potokov-operator-synchronized">Синхронизация потоков. Оператор synchronized в Java</a></li>
        </ol>
    </div>

    <section>
        <h2>Способы синхронизация</h2>
        <ol>
            <li>wait/notify</li>
            <li>synchronized</li>
            <li>Thread.join</li>
            <li>Lock</li>
            <li>Semaphore</li>
        </ol>
    </section>


    <section>
        <h2>Volatile</h2>
        <p>volatile - ключевое слово для переменной</p>
        <ol>
            <li>Она всегда будет атомарно читаться и записываться. Даже если это 64-битные double или long.</li>
            <li>Java-машина не будет помещать ее в кэш. Так что ситуация, когда 10 потоков работают со своими локальными
                копиями исключена.
            </li>
        </ol>
    </section>

    <section>
        <h2>synchronized</h2>
        <p>synchronized - это ключевое слово, которое позволяет заблокировать доступ к методу или части кода, если его
            уже использует другой поток. По принципу Mutex.
        </p>

        <h3>Применения</h3>
        <ol>
            <li>Для блока кода - если не нужно синхронизировать весь метод. Нужно передавать объект в качестве
                монитора. Обычно передается this, это делает синхронизацию по текущему объекту.
                <pre>
private Object key = new Object();

synchronized (key) {
    System.out.println("Hi I'm synchronized block!");
}
                </pre>
            </li>

            <li>Для метода. В качестве объекта будет текущая ссылка на объект(this).
                <pre>
synchronized void myMethod() {
    System.out.println("Hi I'm synchronized method!");
}
                </pre>

                <p>Можно воспринимать так:</p>
                <pre>
void myMethod() {
    synchronized(this) {
      System.out.println("Hi I'm synchronized method!");
    }
}
                </pre>

                <p>Для статического метода передается .class. По этому статическая блокировка и не статическая на
                    одном
                    классе не будут блокировать друг друга:</p>
                <pre>
static void myMethod() {
    synchronized(MyObject.class) {
      System.out.println("Hi I'm synchronized method!");
    }
}
                </pre>
            </li>
        </ol>
        <p>Минус synchronized - другие потоки вынуждены ждать, пока нужный объект или метод освободится "bottle
            neck".</p>
    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>