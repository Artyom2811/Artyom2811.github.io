<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Multithreading Errors</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../Concurrency.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Multithreading Errors</h1>

	<div class="todo">
		<h2>Проработать</h2>
		<ol>
			<li><a href="https://habr.com/ru/articles/760434/">Разница между Data Race и Race Condition</a></li>
		</ol>
	</div>

    <section>
        <h2>Race condition(состояние гонки)</h2>
        <p>Race condition - ошибка проектирования многопоточной системы или приложения, при которой работа системы или
            приложения зависит от того, в каком порядке выполняются части кода. Гонки между потоками.
        </p>

		<h3>Виды Race Conditions</h3>

		<h4>Write-Write (WW) Race Condition</h4>
		<p>Оба потока записывают в одну и ту же переменную. Проблема: Последнее записанное значение "побеждает",
			и результат зависит от порядка выполнения.
		</p>
		<p>Решение:</p>
		<ul>
			<li>Мьютекс/блокировка → защитить участок записи.</li>
			<li>Атомарная запись (если тип данных поддерживает).</li>
			<li>Разделение данных (каждый поток пишет в свой буфер, потом объединение).</li>
		</ul>

		<h4>Read-Write (RW) Race Condition</h4>
		<p>Один поток читает значение, другой записывает в ту же переменную. Проблема: Чтение может вернуть
			непоследовательное или устаревшее значение.
		</p>
		<p>Решение:</p>
		<ul>
			<li>RWLock (read-write lock) → позволяет множественное чтение, но блокирует запись.</li>
			<li>Volatile/atomic переменные (в Java/C++ гарантируют актуальное значение).</li>
			<li>Copy-on-write структуры (чтение всегда консистентное).</li>
		</ul>

		<h4>Write-Read (WR) Race Condition</h4>
		<p>Один поток пишет, другой сразу читает, но чтение происходит до завершения записи. Проблема: Поток может
			прочитать частично записанное значение.
		</p>
		<p>Решение:</p>
		<ul>
			<li>Атомарная запись (atomic<long>, atomic64).</li>
			<li>Выравнивание и барьеры памяти (на низком уровне).</li>
			<li>Мьютекс при доступе к переменной.</li>
		</ul>

		<h4>Check-Then-Act (Time-of-Check to Time-of-Use / TOCTOU)</h4>
		<p>Сначала проверяется условие, затем оно используется — но между этими действиями состояние может измениться.</p>
		<p>Решение:</p>
		<ul>
			<li>Захват блокировки перед проверкой и действием.</li>
			<li>Атомарные операции (например, compareAndSwap).</li>
			<li>Использовать системные вызовы с проверкой внутри (например, open(O_CREAT|O_EXCL) вместо if (exists) open).</li>
		</ul>

		<h4>Initialization Race</h4>
		<p>Два потока одновременно пытаются инициализировать ресурс. Проблема: ресурс может быть инициализирован дважды.</p>
		<p>Решение:</p>
		<ul>
			<li>Double-checked locking (с volatile/atomic).</li>
			<li>Статическая инициализация (гарантирована компилятором/языком).</li>
			<li>Мьютекс при создании объекта.</li>
		</ul>

		<h4>Lost Update</h4>
		<p>Оба потока читают значение, обновляют его и записывают обратно, теряя изменения друг друга.</p>
		<p>Решение:</p>
		<ul>
			<li>Атомарные операции (atomic.incrementAndGet() / InterlockedIncrement).</li>
			<li>CAS (Compare-And-Swap) цикл для lock-free обновлений.</li>
			<li>Мьютекс вокруг обновления.</li>
		</ul>

		<h4>ABA Problem</h4>
		<p>Поток видит, что значение не изменилось (A → B → A), но на самом деле оно менялось. Особенно важно при
			использовании CAS (Compare-And-Swap). Пример: стек без блокировок может быть нарушен из-за ABA, если другой
			поток удаляет и добавляет элемент обратно.
		</p>
		<p>Решение:</p>
		<ul>
			<li>Версионные счётчики (tagging) → хранить не только значение, но и номер версии.</li>
			<li>Double-wide CAS (CAS по значению + версии).</li>
			<li>Hazard pointers / RCU (для lock-free структур).</li>
		</ul>
    </section>

    <section>
        <h2>Deadlock(взаимная блокировка)</h2>
        <p>Deadlock(взаимная блокировка) - ошибка, когда два или более потоков вечно ожидают друг друга.</p>
		<p>Представьте, что один поток входит в монитор объекта A, а другая — объекта B. Если поток в объекте A пытается
			вызвать любой синхронизированный метод объекта B, а объект A в то же самое время пытается вызвать любой
			синхронизированный метод объекта A, то потоки застрянут в процессе ожидания.
		</p>
    </section>

    <section>
		<h2>Типы Deadlock:</h2>

		<h3>Взаимная блокировка порядка синхронизации</h3>
		<pre>
public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
	synchronized (fromAccount) {
		synchronized (toAccount) {
			if (fromAccount.getBalance().compareTo(amount) < 0)
				throw new InsufficientFundsException();
			else {
				fromAccount.debit(amount);
				toAccount.credit(amount);
			}
		}
	}
}
    	</pre>

		<p>Способ решения - можно всегда делать блокировку в порядке Id объектов. И тогда всегда будет сначала
			блокироваться первый объект. И если он уже занят, будет ожидания его освобождения.
		</p>
		<pre>
private void doTransfer(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException {
	if (fromAcct.getBalance().compareTo(amount) < 0)
		throw new InsufficientFundsException();
	else {
		fromAcct.debit(amount);
		toAcct.credit(amount);
	}
}
public void transferMoney(final Account fromAcct, final Account toAcct, final DollarAmount amount) throws InsufficientFundsException {
	int fromId= fromAcct.getId();
	int toId = fromAcct.getId();
	if (fromId < toId) {
		synchronized (fromAcct) {
			synchronized (toAcct) {
				doTransfer(fromAcct, toAcct, amount)}
			}
		}
	} else  {
		synchronized (toAcct) {
			synchronized (fromAcct) {
				doTransfer(fromAcct, toAcct, amount)}
			}
		}
	}
}
    </pre>

		<h3>Взаимная блокировка между объектами</h3>
		<pre>
class Plane {
	private Point location, destination;
	private final Dispatcher dispatcher;

	public Plane(Dispatcher dispatcher) {
		this.dispatcher = dispatcher;
	}
	public synchronized Point getLocation() {
		return location;
	}
	public synchronized void setLocation(Point location) {
		this.location = location;
		if (location.equals(destination))
		dispatcher.requestLanding(this);
	}
}

class Dispatcher {
	private final Set&lt;Plane&gt; planes;
	private final Set&lt;Plane&gt; planesPendingLanding;

	public Dispatcher() {
		planes = new HashSet&lt;Plane>();
		planesPendingLanding = new HashSet&lt;Plane&gt;();
	}
	public synchronized void requestLanding(Plane plane) {
		planesPendingLanding.add(plane);
	}
	public synchronized Image getMap() {
		Image image = new Image();
		for (Plane plane : planes)
			image.drawMarker(plane.getLocation());
		return image;
	}
}
    	</pre>

		<p>В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может
			возникнуть взаимная блокировка. То есть, будут вызваны методы, getMap и setLocation, которые займут мониторы
			экземпляров Dispatcher и Plane соответственно. Затем метод getMap вызовет plane.getLocation (в частности для
			экземпляра Plane, который в данный момент занят), который будет ждать освобождения монитора для каждого из
			экземпляров Plane. В то же время в методе setLocation будет вызван dispatcher.requestLanding, при этом
			монитор экземпляра Dispatcher остается занят рисованием карты. Результат – взаимная блокировка.
		</p>

		<p>Можно исправить изменив методы:</p>
		<pre>
public void setLocation(Point location) {
	boolean reachedDestination;
	synchronized(this){
		this.location = location;
		reachedDestination = location.equals(destination);
	}
	if (reachedDestination)
		dispatcher.requestLanding(this);
}
………………………………………………………………………………
public Image getMap() {
	Set&lt;Plane&gt; copy;
	synchronized(this){
		copy = new HashSet&lt;Plane&gt;( planes);
	}
	Image image = new Image();
	for (Plane plane : copy)
		image.drawMarker(plane.getLocation());
	return image;
}
    	</pre>
    </section>

	<section>
		<h2>Livelock</h2>
		<p>Потоки живые, но при этом не могут ничего сделать, т.к. условие, по которым они пытаются продолжить свою
			работу, не могут выполниться.
		</p>
		<p>Livelock похож на deadlock, но только потоки не "зависают" в ожидании монитора, а что-то вечно делают.</p>
		<p>Например: 2 потока пытаются захватить оба потока, но если 2-ой поток занят, они должны освободить монитор.
		В итоге они могут долго пытаться это сделать.
		</p>
	</section>

	<section>
		<h2>Starvation(голодание) lock</h2>
		<p>Потоки не заблокированы, а им просто не хватает ресурсов на всех. Поэтому пока одни потоки на себя
			берут всё время выполнения, другие не могут выполниться.
		</p>
	</section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>