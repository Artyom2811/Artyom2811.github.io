<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Scala</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>
<body>
<div><a href="../ProgrammingLanguages.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Scala(Scalable Language)</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://docs.scala-lang.org/overviews/scala-book/futures.html">SCALA FUTURES</a></li>
            <li><a href="https://docs.scala-lang.org/tour/pattern-matching.html">PATTERN MATCHING</a></li>
            <li><a href="https://www.youtube.com/watch?v=1G7oNfP-PZs">Future и Promise</a></li>
            <li><a href="https://www.baeldung.com/scala/futures-promises">futures-promises</a></li>
            <li><a href="https://eax.me/scala-futures/">Перестаем бояться футур (futures) в Scala</a></li>
            <li><a href="https://eax.me/monads/">Собираемся с духом и перестаем бояться монад</a></li>
            <li><a href="https://habr.com/ru/post/209510/">Монады в Scala</a></li>
            <li><a href="https://habr.com/ru/post/233555/">Back to the Scala Future</a></li>
            <li><a href="https://www.youtube.com/watch?v=qdD-NuCRkzA">Scala Futures</a></li>
            <li><a href="https://www.youtube.com/watch?v=hGMndafDcc8">Options in Futures, how to unsuck them</a></li>
            <li><a href="https://xebia.com/blog/try-option-or-either/">Try, Option or Either?</a></li>
            <li><a href="https://habr.com/ru/company/jugru/blog/340178/">Моноиды, полугруппы и все-все-все</a></li>
            <li><a href="https://mageswaran1989.medium.com/null-in-scala-some-interesting-exploration-a7378dea0c77">null in Scala</a></li>
            <li><a href="https://habr.com/ru/post/354028/">Понимаем implicit'ы в Scala</a></li>
            <li><a href="https://habr.com/ru/post/329600/">Как использовать implicit'ы в Scala и сохранить рассудок</a></li>
            <li><a href="https://habr.com/ru/post/440900/">REST страсти по 200</a></li>
            <li><a href="https://apicrazy.com/2014/04/30/loops-in-scala-imperative-tailrecursive/">Loops in Scala (Imperative & Tail Recursive)</a></li>
            <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaErrorHandling">Play - Handling errors</a></li>
            <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaDependencyInjection">Play - Dependency Injection</a></li>
            <li><a href="https://www.playframework.com/documentation/2.8.x/SettingsLogger">Play - Configuring logging</a></li>
            <li><a href="https://www.playframework.com/documentation/2.8.x/ScalaCsrf">Play - Protecting against Cross Site Request Forgery</a></li>
            <li><a href="https://www.playframework.com/documentation/2.8.x/ConfiguringHttps">Play - Configuring HTTPS</a></li>
            <li><a href="https://groz.github.io/scala/intro/futures/">Введение в Scala.</a></li>
            <li><a href="https://docs.scala-lang.org/ru/overviews/collections-2.13/overview.html">ИЗМЕНЯЕМЫЕ И НЕИЗМЕНЯЕМЫЕ КОЛЛЕКЦИИ</a></li>
            <li><a href="https://ru.education-wiki.com/9406244-scala-interview-questions">Scala Интервью Вопросы</a></li>
            <li><a href="https://twitter.github.io/scala_school/ru/index.html">Scala Школа!</a></li>
            <li>cats</li>
            <li><a href="https://temofeev.ru/info/articles/9-sovetov-po-ispolzovaniyu-biblioteki-cats-v-scala/">9 советов по использованию библиотеки Cats в Scala</a></li>
            <li><a href="https://habr.com/ru/company/otus/blog/525618/">5 уроков, которые я извлек для себя, продолжая осваивать ZIO</a></li>
            <li><a href="https://habr.com/ru/post/331138/">Не используйте return в Scala</a></li>
            <li>zio</li>
            <li>Type class vs case class</li>
            <li>Как посчитать количество одинаковых элементов в List?</li>
            <li>Узнать разницу scala .andthan со скобочками и через пробелы?</li>
        </ol>
    </div>

    <section>
        <h2>Что это</h2>
        <p> Это многопарадигмальный язык программирования. Он поддерживает как объектно-ориентированный, так и
            функциональный язык программирования. Это работает для JVM (виртуальная машина Java).
        </p>
    </section>

    <section>
        <h2>Основные разделы</h2>
        <ul>
            <li><a href="case_class/CaseClass.html.html">CaseClass</a></li>
            <li><a href="collections/Collections.html">Collections</a></li>
            <li><a href="for_comprehension/Collections.html">ForComprehension</a></li>
            <li><a href="frameworks/Frameworks.html">Frameworks</a></li>
            <li><a href="#mainStack">Основной scala tech stack</a></li>
            <li><a href="#mainStack">Основной scala tech stack</a></li>
        </ul>
    </section>

    <section>
        <h2 id="mainStack">Основной scala tech stack</h2>
        <ul>
            <li>SBT(scala build tool) - система сборки проекта</li>
            <li>Play Framework - MVC фреймворк.</li>
            <li>Slick - Библиотека работы с БД (http://scala-slick.org/)</li>
            <li>Quill - Библиотека работы с БД (https://getquill.io/)</li>
            <li>Silhouette - Библиотека для аутентификации</li>
        </ul>
    </section>

    <section>
        <h2>Implicit</h2>
        <div>Implicit(Неявное)
            <ol>
                <li>Неявные параметры - параметры соответствующих типов которые будут переданы в качестве параметров.</li>
                <li>Неявные преобразования - позволяют автоматически преобразовать значение одного типа к другому.
                    <pre>
case class A(i: Int)
case class B(i: Int)

implicit def aToB(a: A): B = B(a.i)

val a = A(1)
val b: B = a
println(b)
        </pre>
                </li>
                <li>Неявные классы</li>
            </ol>
            <ol>Пустые типы в scala:
                <li>Nothing - - это самый нижний тип. Переменную с таким типом можно присвоить любое значение. Exception
                    возвращает Nothing
                </li>
                <li>Null - trait который реализован в null</li>
                <li>null - наследник всех объектов, но не наследник всех примитивов.</li>
                <li>Nil - представление пустых списков</li>
                <li>Unit или () - Эквивалент Java void, который используется для функций, не имеющих возвращаемого типа
                </li>
                <li>None - Использует Option</li>
            </ol>
        </div>
    </section>

    <section>
        <h2>Option</h2>
        <p>Option - необходим как обёртка над значением(Some()) или его отсутствие(None). И можно без риска использовать
            функции высшего порядка над переменной(map и тд.).
        </p>
    </section>

    <section>
        <h2>Either and Try</h2>
        <p>Either[Error, T] - это тип, который содержит либо значение, либо исключение.</p>

        <p>Try[T] - это подмножество "Either[Error, T]", который содержит либо значение, либо исключение.
            Может быть мутирован в Option.
        </p>
    </section>

    <section>
        <h2>Способы вызова функции</h2>
        <p>Вызов по значения - def callByValue(x: Int) = {} - переменная будет получена один раз и используется
            в методе.
        </p>

        <p>Вызов по имени - def callByName(x: => Int) = {} - переменная будет переполучаться при каждом вызове x в
            методе.
        </p>

        <pre>С использование функции
def f(x: Int) = x + 3

def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(f, 7))
        </pre>

        <pre>С использованием анонимной функции
def g(f: Int ⇒ Int, x: Int) = f(x) * f(x)

println(g(_ + 3, 7))
        </pre>
    </section>

    <section>
        <h2>Immutable Object</h2>
        <ul>Immutable Object - называется объект, состояние которого не может быть изменено после создания.
            <li>Блокировка для многопоточности больше не является проблемой: если данные не изменяются, нет необходимости в
                какой-либо блокировке, чтобы синхронизировать разные потоки
            </li>
            <li>хранение (persistence) — становится проще.</li>
            <li>копирование возможно за константное время, потому что этот процесс становится лишь вопросом создания
                новой ссылки на уже существующий экземпляр структуры данных.
            </li>
        </ul>
        <p>Недостатки Immutable - используется много Heap(молодой) памяти, так как часто удаляются уже использованные
            объекты.
        </p>
    </section>

    <section>
        <h2>Tuple</h2>
        <p>-> - оператор для создания tuple и Map</p>
        <pre>
val foo = List("r", "r",  "s",  "s",  "x",  "x").toStream.groupBy(i => i).mapValues(_.size)
        </pre>
    </section>

    <section>
        <h2>Exception</h2>
        <p>Exception - в Scala исключения действуют так же как и в JAVA, но тут нет "checked"(то есть компилятор их не
            проверяет) исключений.
            Выражение trow имеет специальный тип Nothing.
        </p>

        <p>Error - не обрабатываемые исключения тк после из возникновений нет гарантий что программа будет выполняться
            корректно.
        </p>
    </section>

    <section>
    <h2>Каррирование(Currying)</h2>
        <p>Каррирование(Currying) - частичный вызов функции(частичное применение), для дальнейшего использования.</p>
        <pre>
def multiply(m: Int)(n: Int): Int = m * n
val timesTwo = multiply(2) _
timesTwo(3)
        </pre>
    </section>

    <section>
        <h2>Alias for import</h2>
        <p>import com.json.{Formatter =&gt; JsonFormatter}</p>
    </section>

    <section>
        <h2>Заметки(Разобрать)</h2>
        <p>Если не стоит стрелка - _ <- detectionImageService.deleteById(imageId) значит Future не выполниться</p>
        <pre>
//Проверка внутри for comprehension
_ = {
  println(s"newPlates = ${newPlates}")
}
        </pre>

        <pre>
Проверка Future из переменной
//TODO: check for Future
Await.result(createdPlatesArray, 10 seconds)
println(s"test = ${createdPlatesArray}")
        </pre>
    </section>

    <section>
        <h2>Pattern matching</h2>
        <p>Часто используемый паттерн для работы с ходом выполнения программы.</p>
        <p>Может использоваться как обычный match(java - switch)</p>
        <pre>
import scala.util.Random

val x: Int = Random.nextInt(10)

x match
  case 0 => "zero"
  case 1 => "one"
  case 2 => "two"
  case _ => "other"
        </pre>

        <p>Также может быть применен для case classes.</p>
        <pre>
sealed trait Notification

case class Email(sender: String, title: String, body: String) extends Notification
case class SMS(caller: String, message: String) extends Notification
case class VoiceRecording(contactName: String, link: String) extends Notification
        </pre>
        <pre>
def showNotification(notification: Notification): String =
  notification match
    case Email(sender, title, _) =>
      s"You got an email from $sender with title: $title"
    case SMS(number, message) =>
      s"You got an SMS from $number! Message: $message"
    case VoiceRecording(name, link) =>
      s"You received a Voice Recording from $name! Click the link to hear it: $link"

val someSms = SMS("12345", "Are you there?")
val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")

println(showNotification(someSms))  // prints You got an SMS from 12345! Message: Are you there?

println(showNotification(someVoiceRecording))  // prints You received a Voice Recording from Tom! Click the link to hear it: voicerecording.org/id/123
        </pre>

        <p></p>

    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>