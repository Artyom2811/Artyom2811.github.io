<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Architecture</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>

<body>
<div><a href="../Other.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Программная архитектура</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://proglib.io/p/monolitnaya-vs-mikroservisnaya-arhitektura-2019-09-16">Монолитная vs Микросервисная архитектура</a></li>
            <li><a href="https://habr.com/ru/articles/491556/">Микросервисы на Java: практическое руководство</a></li>
            <li><a href="https://habr.com/ru/companies/slurm/articles/675682/">Взаимодействие в архитектуре микросервисов</a></li>

            <h3>Системный дизайн</h3>
            <li><a href="https://www.youtube.com/watch?v=cLm5ep2dheE">Архитектурная Ката / Максим Чернухин, Глеб Гончаров</a></li>
            <li><a href="https://www.youtube.com/watch?v=FLFMaXq5mMw">Что нужно знать новичку о системном дизайне? | Все о системном проектировании с примерами</a></li>
            <li><a href="https://www.youtube.com/watch?v=cRahMZHPpPE">Системний Дизайн - Резервування Слоту Під Навантаженням - Java: Про ІТ під каву - #47</a></li>

            <h3>DDD</h3>
            <li><a href="https://www.youtube.com/watch?v=6_BhdXLxiic">Что такое DDD за 10 минут с примерами</a></li>
        </ol>
    </div>

    <ul>Основные разделы:
        <li><a class="anchor" href="#monolith">Monolithic(Монолит)</a></li>
        <li><a class="anchor" href="#multitier">Multitier(Многоуровневый)</a></li>
        <li><a href="microservice/Microservice.html">Microservice(Микросервисы)</a></li>
    </ul>

    <section>
        <h2 id="monolith">Монолит</h2>
        <p>Монолитное приложение(монолит) представляет собой приложение, доставляемое через единое развертывание.
            Таким является приложение, доставленное в виде одной WAR или приложение Node с одной точкой входа.
            Содержит: UI слой, сервис слой, слой работы с БД и тд.
        </p>
    </section>

    <section>
        <h2 id="multitier">Multitier</h2>
        <p>Разделение монолита на несколько частей. Отличие от микросервисов - каждый микросервис может иметь все
            слои в себе. Это значит микросервис - маленький монолит.</p>
        <h3>Обычно разделяется на:</h3>
        <ol>
            <li>Presentation layer(Front-end)</li>
            <li>Logic layer(Back-end)</li>
            <li>Data layer(Database administrators)</li>
        </ol>
    </section>

    <section>
        <h2>Event-Driven Architecture (EDA)</h2>
        <p>Event-Driven Architecture - это архитектурный стиль, основанный на идее обработки событий как основного
            способа взаимодействия между компонентами системы. В такой архитектуре приложения реагируют на события,
            которые могут быть как внутренними (например, изменение состояния системы), так и внешними (например,
            действия пользователя или события, происходящие в других системах).
        </p>

        <h3>Основные принципы</h3>
        <ol>
            <li>Производители событий генерируют события, которые могут быть асинхронными и происходить в любой момент времени.
            </li>
            <li>Потребители событий реагируют на эти события, принимая меры или изменяя свое состояние в ответ.</li>
            <li>Обмен событиями может происходить через системы обмена сообщениями, такие как Kafka, RabbitMQ или AWS SNS.</li>
            <li>Асинхронность и декуплинг между компонентами — компоненты не зависят друг от друга напрямую, а
                взаимодействуют через события.
            </li>
            <li>Масштабируемость — благодаря асинхронности система может легче масштабироваться и выдерживать нагрузку.</li>
        </ol>
    </section>

    <section>
        <h2>Domain-Driven Design (DDD)</h2>
        <p>Domain-Driven Design (Проектирование, ориентированное на предметную область) — это подход к проектированию
            программных систем, который ставит в центр внимания бизнес-логику (предметную область) и требует тесного
            сотрудничества между разработчиками и экспертами в предметной области. В DDD выделяются такие важные
            концепции, как ограниченные контексты, агрегаты, сущности и события домена.
        </p>

        <h3>Основные принципы</h3>
        <ol>
            <li>Обоготворение предметной области — вся разработка фокусируется на точном моделировании и понимании
                бизнес-процессов.
            </li>
            <li>Ограниченные контексты — разделение системы на независимые части, каждая из которых имеет свою модель
                данных и логику, что позволяет избежать сложностей при интеграции.
            </li>
            <li>Агрегаты — это группы объектов, которые обрабатываются как единое целое и обеспечивают консистентность
                данных внутри своих границ.
            </li>
            <li>События домена — события, которые представляют собой значимые изменения в состоянии системы,
                связанные с бизнес-процессами. Эти события могут быть полезными для интеграции с другими частями
                системы или внешними сервисами.
            </li>
        </ol>
    </section>

    <section>
        <h2>Correlation ID</h2>
        <p>Correlation ID - уникальный идентификатор, который используется для отслеживания запросов в распределённых
            системах и микросервисах. Он помогает связывать связанные запросы и упрощает диагностику, логирование
            и мониторинг.
        </p>

        <h3>Зачем нужно</h3>
        <ul>
            <li>Трассировка запросов. В микросервисной архитектуре один пользовательский запрос может порождать
                множество внутренних вызовов. Correlation ID позволяет связать их в единую цепочку.
            </li>
            <li>Упрощение логирования и отладки. Если в логах у каждого запроса есть свой Correlation ID, легче
                проследить, как он обрабатывался, и найти возможные ошибки.
            </li>
            <li>Мониторинг и метрики. Позволяет анализировать производительность и выявлять узкие места в обработке
                запросов.
            </li>
            <li>Диагностика распределённых систем. В распределённых системах запрос может проходить через разные
                сервисы. Correlation ID помогает видеть полную картину обработки запроса.
            </li>
        </ul>

        <h3>Как работает</h3>
        <h4>Генерация</h4>
        <p>Correlation ID создаётся на входе в систему (например, при запросе от клиента).</p>
        <p>Если запрос приходит с уже существующим Correlation ID (например, от другого микросервиса), он сохраняется.</p>

        <h4>Передача</h4>
        <p>Correlation ID передаётся через HTTP-заголовки (например, X-Correlation-ID).</p>
        <p>Может использоваться в логах каждого сервиса.</p>

        <h4>Использование в логах</h4>
        <p>Логи всех сервисов включают Correlation ID, что упрощает анализ.</p>

        <h3>Пример использования:</h3>
        <ol>
            <li>Отправляем запрос в веб-приложение.</li>
            <li>API-шлюз создаёт Correlation ID и передаёт его дальше.</li>
            <li>Backend получает этот ID и использует его в логах.</li>
            <li>Backend вызывает другие микросервисы, передавая тот же ID.</li>
            <li>Все сервисы логируют свои действия с этим ID.</li>
            <li>В случае ошибки или долгого запроса можно легко проследить, где возникла проблема.</li>
        </ol>
    </section>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>