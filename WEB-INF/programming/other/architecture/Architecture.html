<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Architecture</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>

<body>
<div><a href="../Other.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Программная архитектура</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://proglib.io/p/monolitnaya-vs-mikroservisnaya-arhitektura-2019-09-16">Монолитная vs Микросервисная архитектура</a></li>
            <li><a href="https://habr.com/ru/articles/491556/">Микросервисы на Java: практическое руководство</a></li>
            <li><a href="https://habr.com/ru/companies/slurm/articles/675682/">Взаимодействие в архитектуре микросервисов</a></li>

            <h3>Системный дизайн</h3>
            <li><a href="https://www.youtube.com/watch?v=cLm5ep2dheE">Архитектурная Ката / Максим Чернухин, Глеб Гончаров</a></li>
            <li><a href="https://www.youtube.com/watch?v=FLFMaXq5mMw">Что нужно знать новичку о системном дизайне? | Все о системном проектировании с примерами</a></li>
            <li><a href="https://www.youtube.com/watch?v=cRahMZHPpPE">Системний Дизайн - Резервування Слоту Під Навантаженням - Java: Про ІТ під каву - #47</a></li>

            <h3>DDD</h3>
            <li><a href="https://www.youtube.com/watch?v=6_BhdXLxiic">Что такое DDD за 10 минут с примерами</a></li>

            <li><a href="https://habr.com/ru/articles/459620/">TDDx2, BDD, DDD, FDD, MDD и PDD, или все, что вы хотите узнать о Driven Development</a></li>
            <li><a href="https://www.youtube.com/watch?v=N-ro_8te98A">Денис Пинчук: Как внедряли DDD в Яндекс 360. Интервью с руководителем команды backend</a></li>
            <li><a href="https://habr.com/ru/articles/929964/">Практические вопросы архитектуры ПО, из чего строить будем?</a></li>
        </ol>
    </div>

    <section>
        <h2>Основные разделы</h2>
        <ul>
            <li><a class="anchor" href="#monolith">Monolithic(Монолит)</a></li>
            <li><a class="anchor" href="#multitier">Multitier(Многоуровневый)</a></li>
        </ul>
    </section>

    <section>
        <h2 id="monolith">Монолит</h2>
        <p>Монолитное приложение(монолит) представляет собой приложение, доставляемое через единое развертывание.
            Таким является приложение, доставленное в виде одной WAR или приложение Node с одной точкой входа.
            Содержит: UI слой, сервис слой, слой работы с БД и тд.
        </p>
    </section>

    <section>
        <h2 id="multitier">Multitier</h2>
        <p>Разделение монолита на несколько частей. Отличие от микросервисов - каждый микросервис может иметь все
            слои в себе. Это значит микросервис - маленький монолит.</p>
        <h3>Обычно разделяется на:</h3>
        <ol>
            <li>Presentation layer(Front-end)</li>
            <li>Logic layer(Back-end)</li>
            <li>Data layer(Database administrators)</li>
        </ol>
    </section>

    <section>
        <h2>Распределённые системы</h2>
        <p>Распределённые системы — это общая концепция, в которой вычисления распределены между несколькими узлами
            (компьютерами, серверами, сервисами), работающими вместе для достижения общей цели.
        </p>

        <h3>Примеры распределенных систем на java</h3>
        <ol>
            <li><a href="microservice/Microservice.html">Microservice(Микросервисы)</a> - Стек: Spring Boot,
                Spring Cloud, Docker, Kubernetes. Стек: Spring Boot, Spring Cloud, Docker, Kubernetes.
            </li>
            <li>Распределённые вычисления (Big Data, Machine Learning) - Стек: Apache Hadoop, Apache Spark. Пример:
                Аналитическая система для обработки больших данных.
            </li>
            <li>Распределённые базы данных - Стек: Apache Cassandra, Apache Ignite, Redis Cluster. Пример: Глобально
                распределённая база данных для социальной сети.
            </li>
            <li>Распределённые системы на основе акторов - Стек: Akka, Java, Scala. Пример: Чат-приложение с обработкой
                сообщений в реальном времени, где каждый пользователь представлен актором.
            </li>
            <li>Peer-to-Peer (P2P) системы - Стек: JXTA, WebRTC, Netty. Пример: Торрент-клиент или децентрализованное
                приложение для обмена файлами.
            </li>
        </ol>
    </section>

    <section>
        <h2>Виды процессов разработки:</h2>
        <ol>
            <li>TDD(Test-driven development)</li>
            <li>DDT(Data-driven testing)</li>
            <li>BDD(Behavior-driven development)</li>
            <li>DDD(Domain-Driven Design)</li>
        </ol>
    </section>

    <section>
        <h2>Event-Driven Architecture (EDA)</h2>
        <p>Event-Driven Architecture - это архитектурный стиль, основанный на идее обработки событий как основного
            способа взаимодействия между компонентами системы. В такой архитектуре приложения реагируют на события,
            которые могут быть как внутренними (например, изменение состояния системы), так и внешними (например,
            действия пользователя или события, происходящие в других системах).
        </p>

        <h3>Основные принципы</h3>
        <ol>
            <li>Производители событий генерируют события, которые могут быть асинхронными и происходить в любой момент времени.
            </li>
            <li>Потребители событий реагируют на эти события, принимая меры или изменяя свое состояние в ответ.</li>
            <li>Обмен событиями может происходить через системы обмена сообщениями, такие как Kafka, RabbitMQ или AWS SNS.</li>
            <li>Асинхронность и декуплинг между компонентами — компоненты не зависят друг от друга напрямую, а
                взаимодействуют через события.
            </li>
            <li>Масштабируемость — благодаря асинхронности система может легче масштабироваться и выдерживать нагрузку.</li>
        </ol>
    </section>

    <section>
        <h2>Domain-Driven Design (DDD)</h2>
        <p>Domain-Driven Design (Проектирование, ориентированное на предметную область) — это подход к проектированию
            программных систем, который ставит в центр внимания бизнес-логику (предметную область) и требует тесного
            сотрудничества между разработчиками и экспертами в предметной области. В DDD выделяются такие важные
            концепции, как ограниченные контексты, агрегаты, сущности и события домена.
        </p>

        <h3>Основные принципы</h3>
        <ol>
            <li>Domain Model - центрирование на предметной области. Вся разработка фокусируется на точном моделировании
                и понимании бизнес-процессов. Она не просто структура данных, а объединение данных и логики (например,
                классы с методами, а не просто DTO).
            </li>
            <li>Ubiquitous Language - Вся команда (разработчики, аналитики, бизнес) использует единый язык, основанный
                на бизнес-терминах. Этот язык отражается в коде — имена классов, методов и т.п.
            </li>
            <li>Bounded Contexts - Большой бизнес-домен делится на поддомены, каждый из которых реализуется в своем
                ограниченном контексте. Например, "Платежи", "Пользователи", "Отчеты" — это могут быть отдельные модули
                или микросервисы.
            </li>
            <li>Entities и Value Objects. Entity (Сущность) — объект с уникальным идентификатором, который сохраняет
                свою личность во времени (например, User, Order). Value Object (Объект-значение) — определяется только
                своим содержимым (например, Money, Address).
            </li>
            <li>Aggregates и Aggregate Root. Aggregate — группа связанных сущностей и объектов-значений, объединённых
                вокруг одной главной сущности (Aggregate Root). Извне доступ только через корень (например, Order с
                OrderLines).
            </li>
            <li>Domain Events - cобытия, которые описывают что-то важное, что произошло в домене (например,
                OrderPlaced, UserRegistered).
            </li>
        </ol>

        <h3>Когда применять:</h3>
        <ul>
            <li>Сложная предметная область (например, финансы, логистика, страхование).</li>
            <li>Необходимость совместной работы между технарями и бизнесом.</li>
            <li>Проект долгоживущий и будет развиваться.</li>
        </ul>

        <h3>Не подходит если:</h3>
        <ul>
            <li>Проект простой (CRUD-приложение).</li>
            <li>Жесткие сроки и маленькая команда.</li>
            <li>Нет тесного взаимодействия с бизнесом.</li>
        </ul>
    </section>

    <section>
        <h2>Correlation ID</h2>
        <p>Correlation ID - уникальный идентификатор, который используется для отслеживания запросов в распределённых
            системах и микросервисах. Он помогает связывать связанные запросы и упрощает диагностику, логирование
            и мониторинг.
        </p>

        <h3>Зачем нужно</h3>
        <ul>
            <li>Трассировка запросов. В микросервисной архитектуре один пользовательский запрос может порождать
                множество внутренних вызовов. Correlation ID позволяет связать их в единую цепочку.
            </li>
            <li>Упрощение логирования и отладки. Если в логах у каждого запроса есть свой Correlation ID, легче
                проследить, как он обрабатывался, и найти возможные ошибки.
            </li>
            <li>Мониторинг и метрики. Позволяет анализировать производительность и выявлять узкие места в обработке
                запросов.
            </li>
            <li>Диагностика распределённых систем. В распределённых системах запрос может проходить через разные
                сервисы. Correlation ID помогает видеть полную картину обработки запроса.
            </li>
        </ul>

        <h3>Как работает</h3>

        <h4>Генерация</h4>
        <p>Correlation ID создаётся на входе в систему (например, при запросе от клиента).</p>
        <p>Если запрос приходит с уже существующим Correlation ID (например, от другого микросервиса), он сохраняется.</p>

        <h4>Передача</h4>
        <p>Correlation ID передаётся через HTTP-заголовки (например, X-Correlation-ID).</p>
        <p>Может использоваться в логах каждого сервиса.</p>

        <h4>Использование в логах</h4>
        <p>Логи всех сервисов включают Correlation ID, что упрощает анализ.</p>

        <h3>Пример использования:</h3>
        <ol>
            <li>Отправляем запрос в веб-приложение.</li>
            <li>API-шлюз создаёт Correlation ID и передаёт его дальше.</li>
            <li>Backend получает этот ID и использует его в логах.</li>
            <li>Backend вызывает другие микросервисы, передавая тот же ID.</li>
            <li>Все сервисы логируют свои действия с этим ID.</li>
            <li>В случае ошибки или долгого запроса можно легко проследить, где возникла проблема.</li>
        </ol>
    </section>
</div>
</body>
<script>setBackButtonHeight();</script>
</html>