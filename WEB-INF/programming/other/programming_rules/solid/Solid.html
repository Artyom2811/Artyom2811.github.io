<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Solid</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../ProgrammingRules.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Solid</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://javarush.ru/groups/posts/osnovnye-principy-dizajna-klassov-solid-v-java">Пять основных принципов дизайна классов (S.O.L.I.D.) в Java</a></li>
            <li><a href="https://habr.com/ru/articles/779510/">Пример для иллюстрации принципов SOLID который я (кажется) понял</a></li>
        </ol>
    </div>

    <section>
        <h2>Что это</h2>
        <p>Solid - основные принципы объектно-ориентированного программирования и проектирования.</p>
    </section>

    <section>
        <h2>Описание</h2>
        <h2>SOLID</h2>
        <ol>
            <li>Принцип единственной ответственности(single responsibility) - на каждый объект должна быть возложена одна
                единственная обязанность. Если сканер-принтер - нужно разделить.
            </li>
            <li>Принцип открытости/закрытости(open–closed) - программные сущности должны быть открыты для расширения,
                но закрыты для модификации. Интерфейс Shape с методом calculateArea(). Создаем реализации его
                (Circle, Rectangle) и описываем метод. А не в Shape описываем все возможные calculateArea().
            </li>
            <li>Принцип подстановки Барбары Лисков(Liskov substitution) - объекты в программе должны быть заменяемыми
                на экземпляры их подтипов без изменения программы. Или наследующий класс должен дополнять, а не замещать
                поведение базового класса. Мы должны всегда иметь возможно заменить в любом месте программы родительский
                класс на дочерний, без влияния на выполнение программы. Чтобы когда мы указываем родителя как тип переменной
                мы должны быть уверенны что каждый наследник который будет помещен будет выполнять его методы как мы ожидаем.
            </li>
            <li>Принцип разделения интерфейса(interface segregation) - много специальных интерфейсов лучше, чем один
                общий интерфейс. Убирает необходимость реализации тех методов которые мы не будем использовать.
            </li>
            <li>Принцип инверсии зависимостей(dependency inversion) - зависимость на Абстракциях. Модули верхних уровней
                не должны зависеть от модулей нижних уровней. Всё должно зависеть от абстракции. Хороший пример:
                реализации мест хранения информации(БД).
            </li>
        </ol>
    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>