<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Data Structure</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js" defer></script>
</head>

<body>
<div><a href="../Other.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>Структуры данных</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://www.youtube.com/watch?v=ZRdOb4yR0kk">Оценка сложности алгоритма. Сложность алгоритмов. Big O, Большое О</a></li>
        </ol>
    </div>

    <section>
        <h2>Что это</h2>
        <p>Структура данных - это контейнер, информация в котором скомпонована характерным образом. Для каждой задачи -
            необходима своя.
        </p>
    </section>

    <section>
        <h2>Основные разделы</h2>
        <ul>
            <li><a class="anchor" href="#array">Массивы</a></li>
            <li><a class="anchor" href="#stack">Стеки</a></li>
            <li><a class="anchor" href="#queue">Очереди</a></li>
            <li><a class="anchor" href="#list">Связные списки</a></li>
            <li><a class="anchor" href="#graph">Графы</a></li>
            <li><a class="anchor" href="#tree">Деревья</a></li>
            <li><a class="anchor" href="#bor">Боры</a></li>
            <li><a class="anchor" href="#hash">Хеш-таблицы</a></li>
        </ul>
    </section>

    <section>
        <h2 id="array">Массивы</h2>
        <p>Массивы - это простейшая и наиболее распространенная структура данных. Стеки и очереди, производны от
            массивов.
        </p>

        <h3>Есть два типа:</h3>
        <ol>
            <li>Одномерные.</li>
            <li>Многомерные - содержат другие массивы.</li>
        </ol>

        <h3>Операции с массивами:</h3>
        <ol>
            <li>Insert — вставляем элемент на позицию с заданным индексом.</li>
            <li>Get — возвращаем элемент, занимающий позицию с заданным индексом.</li>
            <li>Delete — удаляем элемент с заданным индексом.</li>
            <li>Size — Получаем общее количество элементов в массиве.</li>
        </ol>
    </section>

    <section>
        <h2 id="stack">Стеки</h2>
        <p>Стеки - линейная структура где все храниться в виде последовательной стопки (LIFO). Пример: Ctrl+Z или
            Stack память JAVA.
        </p>

        <h3>Операции со стеками:</h3>
        <ol>
            <li>Push — Вставляет элемент в стек сверху.</li>
            <li>Pop — Возвращает верхний элемент после того, как удалит его из стека.</li>
            <li>isEmpty — Возвращает true, если стек пуст.</li>
            <li>Top — Возвращает верхний элемент, не удаляя его из стека.</li>
        </ol>
    </section>

    <section>
        <h2 id="queue">Очереди</h2>
        <p>Очереди - линейная структура как стек, но по принципу FIFO.</p>

        <h3>Операции с очередями:</h3>
        <ol>
            <li>Enqueue() — Добавляет элемент в конец очереди.</li>
            <li>Dequeue() — Удаляет элемент из начала очереди.</li>
            <li>isEmpty() — Возвращает true, если очередь пуста.</li>
            <li>Top() — Возвращает первый элемент в очереди.</li>
        </ol>
    </section>

    <section>
        <h2 id="list">Связные списки</h2>
        <p>Связные списки - линейная структура данных, похожа на массив. Отличается от массива по выделению
            памяти, внутренней структуре и процессу выполнения операции вставки и удаления. Состоит из цепочки
            узлов(Данные и ссылка на следующий элемент). Есть головной указатель, соответствующий первому элементу
            в связном списке, и, если список пуст, то он направлен просто на null.
        </p>

        <h3>Есть два типа:</h3>
        <ol>
            <li>Односвязный список (однонаправленный).</li>
            <li>Двусвязный список (двунаправленный).</li>
        </ol>

        <h3>Операции с массивами:</h3>
        <ol>
            <li>InsertAtEnd — Вставляет заданный элемент в конце связного списка.</li>
            <li>InsertAtHead — Вставляет заданный элемент в начале (с головы) связного списка.</li>
            <li>Delete — Удаляет заданный элемент из связного списка.</li>
            <li>DeleteAtHead — Удаляет первый элемент в связном списке.</li>
            <li>Search — Возвращает заданный элемент из связного списка.</li>
            <li>isEmpty — Возвращает true, если связный список пуст.</li>
        </ol>
    </section>

    <section>
        <h2 id="graph">Графы</h2>
        <p>Графы - это множество узлов, соединенных друг с другом в виде сети. Узлы также называются вершинами.
            Пара (x,y) называется ребром, это означает, что вершина x соединена с вершиной y. Ребро может иметь
            вес/стоимость — показатель, характеризующий, насколько затратен переход от вершины x к вершине y.
        </p>
        <img src="graf.png" width="80%">

        <h3>Типы графов:</h3>
        <ol>
            <li>Неориентированный граф.</li>
            <li>Ориентированный граф.</li>
        </ol>

        <h3>В языке программирования графы могут быть двух видов:</h3>
        <ol>
            <li>Матрица смежности.</li>
            <li>Список смежности.</li>
        </ol>

        <h3>Распространенные алгоритмы обхода графа:</h3>
        <ol>
            <li>Поиск в ширину.</li>
            <li>Поиск в глубину.</li>
        </ol>
    </section>

    <section>
        <h2 id="tree">Деревья</h2>
        <p>Деревья - это иерархическая структура данных, состоящая из вершин (узлов) и ребер, которые их
            соединяют. Деревья подобны графам, однако, ключевое отличие дерева от графа таково: в дереве не бывает
            циклов.
        </p>
        <img src="tree.png" width="80%">

        <h3>Типы деревьев:</h3>
        <ol>
            <li>N-арное дерево.</li>
            <li>Сбалансированное дерево.</li>
            <li>Двоичное дерево.</li>
            <li>Двоичное дерево поиска.</li>
            <li>АВЛ-дерево.</li>
            <li>Красно-черное дерево.</li>
            <li>2—3 дерево.</li>
        </ol>

        <h3>Способы обхода деревьев:</h3>
        <ol>
            <li>В глубину.
                <ol>
                    <li>Прямой обход(Pre-order)(NLR) - использовать когда вы знаете что нужно проверить руты перед тем как
                        проверять их листья.
                    </li>
                    <img src="tree_nlr.png" width="80%">
                    <li>Центрированный обход(In-order)(LNR) - используется как когда нужно проверять в начале детей и только
                        потом подыматься к родительским узлам.
                    </li>
                    <img src="tree_lnr.png" width="80%">
                    <li>Обратный обход(Post-order)(LRN) - когда нужно начать-так сказать с листов и завершить главным узлом —
                        то есть разложить дерево на то, как оно строилось.
                    </li>
                    <img src="tree_lrn.png" width="80%">
                </ol>
            </li>
            <li>В ширину - посещаем каждый узел на уровне прежде чем перейти на следующий уровень.</li>
            <img src="tree_width.png" width="80%">
        </ol>
    </section>

    <section>
        <h2 id="bor">Боры(префиксное дерево)</h2>
        <p>Боры(префиксное дерево) - это древовидная структура данных, которая особенно эффективна при решении
            задач на строки. Она обеспечивает быстрое извлечение данных и чаще всего применяется для поиска слов в
            словаре, автозавершений в поисковике и даже для IP-маршрутизации.
            Вот как три слова «top» (верх), «thus» (следовательно), and «their» (их) хранятся в бору:
        </p>
        <img src="bor.png" width="40%">
    </section>

    <section>
        <h2 id="hash">Хеш-таблицы</h2>
        <p>Хеш-таблицы - хеширование — это процесс, применяемый для уникальной идентификации объектов и
            сохранения каждого объекта по заранее вычисленному индексу, именуемому его «ключом». Таким образом, объект
            хранится в виде «ключ-значение», а коллекция таких объектов называется «словарь». Каждый объект можно искать
            по его ключу. Существуют разные структуры данных, построенные по принципу хеширования, но чаще всего из
            таких структур применяется хеш-таблица.
        </p>
    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>