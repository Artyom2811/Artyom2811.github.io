<!DOCTYPE HTML>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>HTTP</title>
    <link rel="stylesheet" href="/style.css">
    <script src="/script.js"></script>
</head>

<body>
<div><a href="../СommunicationProtocols.html" class="backButton"></a></div>
<div class="bodyStyle">
    <h1>HTTP</h1>

    <div class="todo">
        <h2>Проработать</h2>
        <ol>
            <li><a href="https://habrahabr.ru/post/50147/">Типы HTTP-запросов и философия REST</a></li>
            <li><a href="https://hackernoon.com/restful-api-design-step-by-step-guide-2f2c9f9fcdbf">RESTful API Design</a></li>
            <li><a href="https://www.youtube.com/watch?v=SMy4CaxizbA">gRPC-- Альтернатива REST от google</a></li>
            <li><a href="https://dou.ua/lenta/articles/rest-conception/">Синхронизируем понимание REST</a></li>
            <li><a href="https://habr.com/ru/company/hexlet/blog/274675/">Что такое RESTful на самом деле</a></li>
            <li><a href="https://habr.com/ru/articles/351890/">REST API Best Practices</a></li>
            <li><a href="https://jazzteam.org/ru/technical-articles/restful-services-manual/">Лучшие практики проектирования REST API</a></li>
            <li><a href="https://medium.com/@andr.ivas12/rest-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%8B%D0%BC-%D1%8F%D0%B7%D1%8B%D0%BA%D0%BE%D0%BC-90a0bca0bc78">REST: простым языком</a></li>
            <li><a href="https://habr.com/ru/articles/50147/">Типы HTTP-запросов и философия REST</a></li>
            <li><a href="https://www.youtube.com/watch?v=fG4dkrlaZAA">REST API (HTTP) vs Websockets - Concept Overview With Example</a></li>
            <li><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Cookies">HTTP-куки</a></li>
            <li><a href="https://spring-projects.ru/understanding/rest/">Понимание REST</a></li>

        <h3>MIME - header - Content-Type</h3>
            <li><a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_MIME-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2">Список MIME-типов</a></li>
            <li><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME types</a></li>
        </ol>
    </div>

    <section>
        <h2>Что это</h2>
        <p>HTTP(HyperText Transfer Protocol) - является протоколом клиент-серверного взаимодействия без сохранения
            промежуточного состояния. В роли клиента чаще всего выступает веб-браузер. Для обмена информацией протокол
            HTTP в большинстве случаев использует TCP/IP.
        </p>
    </section>

    <section>
        <h2>Основные разделы</h2>
        <ul>
            <li><a class="anchor" href="#connectionProtocols">Протоколы передачи данных</a></li>
            <li><a class="anchor" href="#httpStructure">HTTP запрос структура</a></li>
            <li><a class="anchor" href="#httpMethod">HTTP методы</a></li>
            <li><a class="anchor" href="#stateCodes">Коды состояния</a></li>
            <li><a class="anchor" href="#rest">REST</a></li>
            <li><a class="anchor" href="#robustnessPrinciple">Robustness principle(Postel’s Law)</a></li>
            <li><a class="anchor" href="#idempotency">Идемпотентность</a></li>
            <li><a class="anchor" href="#session">Http сессия</a></li>
        </ul>
    </section>

    <section>
        <h2 id="connectionProtocols">Протоколы передачи данных</h2>
        <p>HTTP(Hypertext Transfer Protocol) - протокол прикладного уровня передачи данных, изначально — в виде
            гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.
            Если не указывать порт будет использован стандартный - "80".
        </p>
        <p>HTTPS(HyperText Transfer Protocol Secure) - расширение протокола HTTP для поддержки шифрования в целях
            повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или устаревшего
            в 2015 году SSL. Если не указывать порт будет использован стандартный - "443". Для проверки качества TLS/SSL
            защиты можно использовать ресурс "ssllabs.com/ssltest/index.html"
        </p>
    </section>

    <section>
        <h2 id="httpStructure">HTTP запрос структура</h2>
        <ol>
            <li>Стартовая строка</li>
            <li><a class="anchor" href="#headers">Заголовки</a></li>
            <li>Тело Сообщения</li>
        </ol>

        <h3 id="headers">Заголовки(Headers)</h3>
        <p>Значение header не может быть null.</p>
        <ol>
            <li>Host - для указания к какому приложению обращаться, если на сервере есть несколько приложений.</li>
            <li>Content-Type - сообщает передаваемый тип данных с помощью MIME отметок.</li>
        </ol>
    </section>

    <section>
        <h2 id="httpMethod">HTTP методы</h2>
        <ol>
            <li>GET — получение ресурса. Передает данные серверу используя URL(1024 символами).</li>
            <li>POST — создание ресурса.</li>
            <li>PUT — обновление ресурса.</li>
            <li>PATCH — обновляет часть ресурса.</li>
            <li>DELETE — удаление ресурса.</li>
            <li>HEAD — используется для получения метаинформации об объекте без пересылки тела HTTP сообщения.</li>
            <li>OPTIONS - для получения параметров текущего HTTP соединения.</li>
            <li>TRACE - используется для получения информации о том, что происходит с сообщением на промежуточных
                узлах.
            </li>
        </ol>
    </section>

    <section>
        <h2 id="stateCodes">Коды состояния</h2>
        <ul>
            <li>200 - OK. Используется для GET и DELETE.</li>
            <li>201 - Created.  Используется для POST, PUT.</li>
            <li>400 - Bad Request</li>
            <li>401 - Unauthorized - необходима авторизация.</li>
            <li>403 - Forbidden - нет прав доступа к содержимому.</li>
            <li>404 - Not Found - ресурс не найден.</li>
        </ul>
    </section>

    <section>
        <h2 id="rest">REST</h2>
        <p>REST(Representational State Transfer) - архитектурный стиль(подход) для создания API в HTTP.
            Другими словами это набор правил о том, как программисту организовать написание кода серверного приложения,
            чтобы все системы легко обменивались данными и приложение можно было масштабировать.
        </p>

        <h3>Требования к архитектуре REST</h3>
        <ol>Основные разделы:
            <li>Модель клиент-сервер.</li>
            <li>Отсутствие состояния(клиента).</li>
            <li>Кэширование.</li>
            <li>Единообразие интерфейса.</li>
            <li>Слои - применение промежуточных серверов способно повысить масштабируемость за счёт балансировки нагрузки и
                распределённого кэширования.
            </li>
            <li>Код по требованию(необязательный) - исполнение кода на стороне клиента.</li>
        </ol>
    </section>

    <section>
        <h2 id="robustnessPrinciple">Robustness principle(Postel’s Law)</h2>
        <p><a href="https://engineering.klarna.com/why-you-should-follow-the-robustness-principle-in-your-apis-b77bd9393e4b">Robustness principle</a>
            - принцип объясняющий почему лучше не делать проверку на строгую схему протокола передачи. Коротко в запросе
            могут быть другие параметры которые будут проигнорированы системой. Коротко - не нужно проверять JSON на
            отсутствие других полей. Убирает необходимость синхронизировать релизы зависимых сервисов.
        </p>
    </section>

    <section>
        <h2 id="idempotency">Идемпотентность</h2>
        <p>Идемпотентность(Idempotency) - это запрос, который выполняется всегда с одним результатом.
            Но ответ на запрос может быть разный. Пример "DELETE" первый запрос возвращает 200, а последующие 404.
            Http методы: GET, HEAD, PUT, OPTIONS, TRACE и DELETE.
        </p>
    </section>

    <section>
        <h2 id="session">Http сессия</h2>
        <p>Сеанс (сессия) – соединение между клиентом и сервером, устанавливаемое на определенное время, за которое
            клиент может отправить на сервер сколько угодно запросов. Так как при посещении клиентом Web-ресурса и
            выполнении вариантов запросов, контекстная информация о клиенте не хранится(stateless). В протоколе HTTP нет
            возможностей для сохранения и изменения информации о предыдущих посещениях клиента. Каждый клиент
            устанавливает с сервером свой собственный сеанс. Сеансы используются для обеспечения хранения данных во
            время нескольких запросов Web-страницы или на обработку информации, введенной в пользовательскую форму в
            результате нескольких HTTP-соединений.
        </p>
        <p>Данные получаются и сохраняются в сессии при помощи соответствующего "ключа".</p>
        <p>Контейнер сервлетов при любом запросе проверяет, есть ли в запросе параметр ID сессии. Если Да(например,
            клиент первый раз обращается к серверу), тогда контейнер сервлетов создает новый объект HttpSession,
            а также присваивает ему уникальный ID. Объект сессии сохраняется на сервере, а ID отправляется в ответе
            клиенту и по умолчанию сохраняется на клиенте в куках. Затем, когда приходит новый запрос от того же клиента,
            то контейнер сервлетов достает из него ID, и по этому ID находит правильный объект HttpSession на сервере.
        </p>
        <p>Получить объект сессии можно из запроса (объект HttpServletRequest), у которого нужно вызвать метод
            getSession(). Он возвращает объект HttpSession.
        </p>

        <p>Способы обеспечения уникального идентификатора сессии:</p>
        <ol>
            <li>User Authentication – предоставление учетных данных самим пользователем в момент аутентификации.
                Переданная таким образом информация в дальнейшем используется для поддержания сеанса. Это метод
                не будет работать, если пользователь вошёл в систему одновременно из нескольких мест.
            </li>
            <li>HTML Hidden Field – присвоение уникального значения скрытому полю HTML страницы, в момент когда
                пользователь начинает сеанс. Этот метод не может быть использован со ссылками, потому что нуждается в
                подтверждении формы со скрытым полем каждый раз во время формирования запроса. Кроме того, это
                не безопасно, т.к. существует возможность простой подмены такого идентификатора.
            </li>
            <li>URL Rewriting – добавление идентификатора сеанса как параметра URL. Достаточно утомительная операция,
                потому что требует постоянного отслеживания этого идентификатора при каждом запросе или ответе.
            </li>
            <li>Cookies – использование небольших фрагментов данных, отправленных web-сервером и хранимых на устройстве
                пользователя. Данный метод не будет работать, если клиент отключает использование cookies.
            </li>
            <li>Session Management API – использование специального API для отслеживания сеанса, построенный на основе
                и на методах, описанных выше. Который решает частные проблемы перечисленных способов -
                чаще всего недостаточно просто отслеживать сессию, необходимо ещё и сохранять какие-либо дополнительные
                данные о ней. Которые могут потребоваться при обработке последующих запросов. Осуществление такого
                поведения требует много дополнительных усилий.
            </li>
        </ol>
    </section>

</div>
</body>
<script>setBackButtonHeight();</script>
</html>